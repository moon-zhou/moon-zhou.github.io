{"meta":{"title":"弦 博客","subtitle":"keep doing","description":"never stop","author":"moon zhou","url":"https://moon-zhou.github.io","root":"/"},"pages":[{"title":"分类","date":"2017-12-02T13:01:24.000Z","updated":"2019-09-08T08:49:32.160Z","comments":false,"path":"categories/index.html","permalink":"https://moon-zhou.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-07T12:42:37.000Z","updated":"2019-09-08T07:32:00.555Z","comments":true,"path":"tags/index.html","permalink":"https://moon-zhou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HashMap源码1","slug":"HashMap源码1","date":"2019-09-22T09:23:34.000Z","updated":"2019-09-22T08:01:35.470Z","comments":true,"path":"2019/09/22/HashMap源码1/","link":"","permalink":"https://moon-zhou.github.io/2019/09/22/HashMap源码1/","excerpt":"背景 来自年龄的焦虑，多学一点，深入一点 由浅入深，本次先进行基础的分析 基本知识点 键值映射的数据结构，每一个键值对也叫做Entry/Node 无序 允许插入 null 的键和值 非线程安全","text":"背景 来自年龄的焦虑，多学一点，深入一点 由浅入深，本次先进行基础的分析 基本知识点 键值映射的数据结构，每一个键值对也叫做Entry/Node 无序 允许插入 null 的键和值 非线程安全 基本结构 初始大小16 1234/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 手动初始化或者自动扩展时，长度必须是2的幂，详情 123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 无hash碰撞时，按数组存储 hash碰撞后，碰撞的Entry/Node通过链表的方式进行存储 1.7里冲突节点使用“头插法”（类比栈，==后插入的Entry被查找的可能性更大==） 1.8里当链表长度大于 8 时==有可能==转为红黑树存储，且为“尾插法”（类比队列）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 桶的树化阈值：链表长度大于 8 时，有可能会转化成树/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;// 桶的链表还原阈值：当在扩容（resize()）时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树退化为链表/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;// 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表（即将链表 转换成红黑树）// 也就是说在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64;/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125; 扩容：resize() 条件：HashMap.Size &gt; Capacity * LoadFactor 扩大到原来容量的两倍，并对键重新散列 1234567891011/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123;&#125; 哈希函数 常用方法：除留余数法（为了均匀地散列键的散列值，通常都会把数组的大小取素数（HashTable 的初始大小就是 11），因为素数的因子少，余数相等的概率小，冲突的几率就小。） HashMap 的容量始终是 2 的次幂，这是一个合数，之所以这样设计，是为了将==取模运算转为位运算==，提高性能。这个等式h % length = h &amp; (length-1)成立的原因如下： 12342^1 = 10 2^1 -1 = 01 2^2 = 100 2^2 -1 = 011 2^3 = 1000 2^3 -1 = 01112^n = 1(n个零) 2^n -1 = 0(n个1) 转为位运算后，length-1 就相当于一个低位掩码，在按位与时，它会把原散列值的高位置0，这就导致散列值只在掩码的小范围内变化，显然增大了冲突几率。为了减少冲突，HashMap 在设计散列算法时，使用高低位异或，变相的让键的高位也参与了运算 12345678910static final int hash(Object key) &#123; // JDK8 int h; // h = key.hashCode() 1. 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 2. 高16位与低16位异或，变相保留高位的比特位 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// JDK7 的源码，JDK8 没有这个方法，但原理一样static int indexFor(int h, int length) &#123; return h &amp; (length-1); // 3. 取模运算&#125; 非线程安全 线程间的竞争条件主要是发生冲突或扩容时，链表的断链和续链操作。 参考 https://juejin.im/post/5d7ec6d4f265da03b76b50ff https://juejin.im/post/5a215783f265da431d3c7bba https://www.cnblogs.com/chinajava/p/5808416.html","categories":[{"name":"源码","slug":"源码","permalink":"https://moon-zhou.github.io/categories/源码/"}],"tags":[]},{"title":"HashMap初始化容量设置思考","slug":"HashMap初始化容量设置思考","date":"2019-09-21T09:23:34.000Z","updated":"2019-09-22T08:01:47.283Z","comments":true,"path":"2019/09/21/HashMap初始化容量设置思考/","link":"","permalink":"https://moon-zhou.github.io/2019/09/21/HashMap初始化容量设置思考/","excerpt":"结论当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。但是这个值并没有参考loadFactor的值。 也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。 如果我们通过expectedSize / 0.75F + 1.0F计算，7/0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。 当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成expectedSize/0.75 + 1的话，可以有效的减少冲突也可以减小误差。【+1为取上整】 所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成expectedSize / 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。","text":"结论当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。但是这个值并没有参考loadFactor的值。 也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。 如果我们通过expectedSize / 0.75F + 1.0F计算，7/0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。 当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成expectedSize/0.75 + 1的话，可以有效的减少冲突也可以减小误差。【+1为取上整】 所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成expectedSize / 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。 初始化核心算法 根据用户传入的容量值（代码中的cap），通过计算，得到第一个比他大的2的幂并返回。 核心算法代码： 1234567int n = cap - 1;n |= n &gt;&gt;&gt; 1;n |= n &gt;&gt;&gt; 2;n |= n &gt;&gt;&gt; 4;n |= n &gt;&gt;&gt; 8;n |= n &gt;&gt;&gt; 16;return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; 其实是对一个二进制数依次向右移位，然后与原值取或。目的对于一个数字的二进制，从第一个不为0的位开始，把后面的所有位都设置成1。 1100 1100 1100 &gt;&gt;&gt;1 = 0110 0110 01101100 1100 1100 | 0110 0110 0110 = 1110 1110 11101110 1110 1110 &gt;&gt;&gt;2 = 0011 1011 10111110 1110 1110 | 0011 1011 1011 = 1111 1111 11111111 1111 1111 &gt;&gt;&gt;4 = 1111 1111 11111111 1111 1111 | 1111 1111 1111 = 1111 1111 1111 做一下极限值的判断，然后把Step 1得到的数值+1。 参考 https://juejin.im/post/5cb3e3d4f265da039d327633","categories":[{"name":"源码","slug":"源码","permalink":"https://moon-zhou.github.io/categories/源码/"}],"tags":[]},{"title":"日常问题汇总-二","slug":"日常问题汇总-二","date":"2019-09-16T09:23:34.000Z","updated":"2019-09-22T08:01:29.820Z","comments":true,"path":"2019/09/16/日常问题汇总-二/","link":"","permalink":"https://moon-zhou.github.io/2019/09/16/日常问题汇总-二/","excerpt":"背景 某系统需要针对访问参数做安全性验证 底层抽象公共校验方法时，使用正则验证实现 正则加载过程逻辑发生了错误","text":"背景 某系统需要针对访问参数做安全性验证 底层抽象公共校验方法时，使用正则验证实现 正则加载过程逻辑发生了错误 设计思想 校验规则工具类、静态验证方法 规则定义存储在类的静态变量 常规验证规则在代码里写死配置在类变量里，动态规则配置在分布式配置中心里（一个） 因为规则是类的静态变量，所以每次调用校验方法时，获取分布式配置里的规则，替换掉最后一个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class XssShieldUtil &#123; /** 日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(XssShieldUtil.class); // 规则 private static List&lt;Pattern&gt; patterns = null; /** XSS字符过滤正则 */ private static final String PATTERN_XSS_CHAR = &quot;(\\\\s|\\\\[|\\\\]|\\\\(|\\\\))*&quot;; /** * 功能描述: XSS特殊字符检查&lt;br&gt; * 〈详细功能描述〉 * * @param value 参数 * @return boolean */ public static boolean includeXss(String value) &#123; if(StringUtils.isBlank(value)) &#123; return false; &#125; return !StringUtils.equals(value, stripXss(value)); &#125; /** * 功能描述: XSS特殊字符过滤&lt;br&gt; * 〈详细功能描述〉 * * @param value 参数 * @return String */ public static String stripXss(String value) &#123; if(StringUtils.isNotBlank(value)) &#123; Matcher matcher = null; for(Pattern pattern : getPatterns()) &#123; matcher = pattern.matcher(value); // 匹配 if(matcher.find()) &#123; // 删除相关字符串 value = matcher.replaceAll(&quot;&quot;); &#125; &#125; value = value.replaceAll(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).replaceAll(&quot;&gt;&quot;, &quot;&amp;gt;&quot;); LOGGER.info(&quot;stripXss after filter value=&#123;&#125;&quot;, value); &#125; return value; &#125; private static List&lt;Pattern&gt; getPatterns() &#123; if (patterns == null) &#123; List&lt;Pattern&gt; list = new ArrayList&lt;Pattern&gt;(); String regex = null; Integer flag = null; int arrLength = 0; // bug1:类级的方法，里面包含了类级的变量，访问时没有做并发控制，存在并发问题。即list有用户在遍历时，依然 for(Object[] arr : getXssPatternList()) &#123; arrLength = arr.length; // bug2: 不需要循环，循环之后，arrLength为2，list为不为7，为14，即相同的固定值塞了两个一模一样的 for(int i = 0; i &lt; arrLength; i++) &#123; regex = (String)arr[0]; flag = (Integer)arr[1]; list.add(Pattern.compile(regex, flag)); &#125; &#125; patterns = list; &#125; // 第八条规则动态从分布式配置中心里获取加载，替换原来的 // 初衷是好的，但是这里造成了bug3：从一开始就不为8，那么造成list一直在增加，最终会导致OOM if(8 == patterns.size())&#123; patterns.remove(patterns.size() - 1); &#125; String pattern = ScmProperties.getInstance().getValue(IdsConstants.PATTERN_XSS_CHAR); LOGGER.info(&quot;call getPatterns patternXssChar=&#123;&#125;&quot;, pattern); pattern = StringUtils.isEmpty(pattern) ? PATTERN_XSS_CHAR : pattern; patterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE)); return patterns; &#125; // 7条固定规则 private static List&lt;Object[]&gt; getXssPatternList() &#123; List&lt;Object[]&gt; ret = new ArrayList&lt;Object[]&gt;(); ret.add(new Object[]&#123;&quot;regex rule1&quot;, Pattern.CASE_INSENSITIVE&#125;); ret.add(new Object[]&#123;&quot;regex rule2&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL&#125;); ret.add(new Object[]&#123;&quot;regex rule3&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL&#125;); ret.add(new Object[]&#123;&quot;regex rule4&quot;, Pattern.CASE_INSENSITIVE&#125;); ret.add(new Object[]&#123;&quot;regex rule5&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL&#125;); ret.add(new Object[]&#123;&quot;regex rule6&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL&#125;); ret.add(new Object[]&#123;&quot;regex rule7&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL&#125;); return ret; &#125; /** * 工具类禁止实例化 */ private XssShieldUtil()&#123;&#125;&#125; 问题汇总 bug1，类变量存在并发问题，有线程在遍历规则list时，有的线程在修改规则list bug2，循环的逻辑本身存在问题 bug3，依赖数目进行控制list大小，当条件不成立时，则大小根本无法控制，最终OOM 修复核心思路 解决并发 解决动态加载规则 核心修改getPatterns() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class XssShieldUtil &#123; /** 日志 */ private static final Logger LOGGER = LoggerFactory.getLogger(XssShieldUtil.class); private static List&lt;Pattern&gt; patterns = null; /** XSS字符过滤正则 */ private static final String PATTERN_XSS_CHAR = &quot;(\\\\s|\\\\[|\\\\]|\\\\(|\\\\))*&quot;; // 规则在类加载的时候给类变量进行初始化 static &#123; patterns.add(Pattern.compile(&quot;regex rule1&quot;, Pattern.CASE_INSENSITIVE)); patterns.add(Pattern.compile(&quot;regex rule2&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)); patterns.add(Pattern.compile(&quot;regex rule3&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)); patterns.add(Pattern.compile(&quot;regex rule4&quot;, Pattern.CASE_INSENSITIVE)); patterns.add(Pattern.compile(&quot;regex rule5&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)); patterns.add(Pattern.compile(&quot;regex rule6&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)); patterns.add(Pattern.compile(&quot;regex rule7&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)); &#125; /** * 功能描述: XSS特殊字符检查&lt;br&gt; * 〈详细功能描述〉 * * @param value 参数 * @return boolean */ public static boolean includeXss(String value) &#123; if(StringUtils.isBlank(value)) &#123; return false; &#125; return !StringUtils.equals(value, stripXss(value)); &#125; /** * 功能描述: XSS特殊字符过滤&lt;br&gt; * 〈详细功能描述〉 * * @param value 参数 * @return String */ public static String stripXss(String value) &#123; if(StringUtils.isNotBlank(value)) &#123; Matcher matcher = null; for(Pattern pattern : getPatterns()) &#123; matcher = pattern.matcher(value); // 匹配 if(matcher.find()) &#123; // 删除相关字符串 value = matcher.replaceAll(&quot;&quot;); &#125; &#125; value = value.replaceAll(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).replaceAll(&quot;&gt;&quot;, &quot;&amp;gt;&quot;); LOGGER.info(&quot;stripXss after filter value=&#123;&#125;&quot;, value); &#125; return value; &#125; private static List&lt;Pattern&gt; getPatterns() &#123; // 创建局部变量返回，避免并发 List&lt;Pattern&gt; newList = new ArrayList&lt;Pattern&gt;(); // 固定规则 newList.addAll(patterns); LOGGER.debug(&quot;newList 1 size=&#123;&#125;&quot;, newList.size()); String pattern = ScmProperties.getInstance().getValue(IdsConstants.PATTERN_XSS_CHAR); LOGGER.info(&quot;call getPatterns patternXssChar=&#123;&#125;&quot;, pattern); pattern = StringUtils.isEmpty(pattern) ? PATTERN_XSS_CHAR : pattern; // 动态规则 newList.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE)); return newList; &#125; /** * 工具类禁止实例化 */ private XssShieldUtil()&#123;&#125;&#125;","categories":[{"name":"问题记录","slug":"问题记录","permalink":"https://moon-zhou.github.io/categories/问题记录/"}],"tags":[]},{"title":"PowerMock基本使用","slug":"PowerMock基本使用","date":"2019-09-14T13:54:39.000Z","updated":"2019-09-14T13:59:15.314Z","comments":true,"path":"2019/09/14/PowerMock基本使用/","link":"","permalink":"https://moon-zhou.github.io/2019/09/14/PowerMock基本使用/","excerpt":"如果页面样式有缺，点击传送门 背景 公司使用的持续部署平台，集成了SonarQube做代码质量检查，其中有单元测试覆盖率的要求。而全链路的测试覆盖率难度较大，如依赖下游系统接口返回结果等。通过MOCK各层数据，化繁为简，大大降低了覆盖代码的运行场景的难度。 团队里人员的更迭，每一个新加入的小伙伴，因为经验和本身学习能力的差异，对从未接触的东西从学习到上手效率不同，且部门没有一个成熟的技术操作文档。 Mockito不能mock静态、final、私有方法等，而PowerMock是在Mockito原有的基础上做了扩展，通过修改类字节码并使用自定义ClassLoader加载运行的方式来实现mock静态方法、final方法、private方法、系统类的功能。（PowerMock直接依赖于Mockito）","text":"如果页面样式有缺，点击传送门 背景 公司使用的持续部署平台，集成了SonarQube做代码质量检查，其中有单元测试覆盖率的要求。而全链路的测试覆盖率难度较大，如依赖下游系统接口返回结果等。通过MOCK各层数据，化繁为简，大大降低了覆盖代码的运行场景的难度。 团队里人员的更迭，每一个新加入的小伙伴，因为经验和本身学习能力的差异，对从未接触的东西从学习到上手效率不同，且部门没有一个成熟的技术操作文档。 Mockito不能mock静态、final、私有方法等，而PowerMock是在Mockito原有的基础上做了扩展，通过修改类字节码并使用自定义ClassLoader加载运行的方式来实现mock静态方法、final方法、private方法、系统类的功能。（PowerMock直接依赖于Mockito） 预备知识 了解基本的单元测试，知道Junit 基本术语 mock：构造虚拟数据，模拟真实方法调用 断言 mock测试流程 创建Mock对象 1List mockedList = mock(List.class); 使用mock对象 12using mock object mockedList.add(“one”); mockedList.clear(); //verification 验证mock对象 123verify(mockedList).add(&quot;one&quot;); verify(mockedList).clear();Assert... 使用 引入依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;2.0.0-RC.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt; &lt;version&gt;2.0.0-RC.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; JUnit常用注解 @RunWith：运行器 @RunWith(JUnit4.class)就是指用JUnit4来运行 @RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境 @RunWith(Suite.class)的话就是一套测试集合 @RunWith(PowerMockRunner.class)，使用PowerMockRunner运行 @Test Mockito里常用注解 @Mock对象：对象生成时不会执行任何构造器方法，方法调用时，不执行方法中的任何内容，返回原始默认值。 @Spy对象：对象生成时执行构造器方法，方法调用时，执行方法中的任何内容。 @InjectMocks对象： 对象生成时会执行构造器方法，如果有多个构造器，则会选择参数最多的构造方法，方法调用时，执行方法中的任何内容。 @InjectMocks注解标注的属性，可以自动注入标记@Mock、@Spy等注解的属性值 @InjectMocks标注的属性不能使用接口，因为@InjectMocks不能传入参数指明实现类 e.g.: 12345// 1、模拟HttpServletRequest对象，不需要依赖web容器，模拟获得请求参数HttpServletRequest request = mock(HttpServletRequest.class); when(request.getParameter(&quot;foo&quot;)).thenReturn(&quot;boo&quot;);// 注意:mock()是Mockito的静态方法，可以用@mock注解替换private @mock HttpServletRequest request Mockito里常用语法 数据打桩：构造虚拟数据，模拟方法返回，注意此方法可以返回多个值 123456when…thenReturn…doReturn…when…（用于spy对象）// 返回多个值，第一次调用返回第一个，后面依次调用对应依次的返回when(mock.someMethod()).thenReturn(value1).thenReturn(value2); when(mock.someMethod()).thenReturn(value1, value2); Answer接口模拟根据参数返回不同结果 123456789101112131415when(userAppMapper.getAppSecretByAppKey(anyString())).thenAnswer( (InvocationOnMock invocationOnMock) -&gt; &#123; String arg = (String) invocationOnMock.getArguments()[0]; if (null == arg || arg.equals(null)) &#123; return null; &#125; else if (arg.equals(&quot;q1w2e3r4t5y6u7i8o9p0&quot;)) &#123; UserApp app = new UserApp(); app.setAppKey(&quot;q1w2e3r4t5y6u7i8o9p0&quot;); app.setAppSecret(&quot;q1w2e3r4t5y6u7i8o9p0&quot;); return app; &#125; else &#123; return null; &#125; &#125;); 方法异常：构造抛异常 12when…thenThrow…doThow…when…（对void 方法进行方法预期设定） 方法是否执行 12doCallRealMethod…when…doNothing…when…（对void 方法进行方法预期设定） 验证行为：Mock对象的执行情况 执行次数 123456verify(mock).method()verify(mock, times(1)).method()verify(mock, atLeastOnce()).method()verify(mock, atLeast(1)).method()verify(mock, atMost(1)).method()verify(mock, never()).method() 超时验证：timeout 方法调用顺序：InOrder verifyNoMoreInteractions verifyZeroInteractions ArgumentCaptor Argument Matcher（参数匹配器）： any(User.class)，匹配任意User对象；anyString()匹配任意字符串；anyInt()匹配任意int型 PowerMock里常用注解 @RunWith(PowerMockRunner.class)：必须在Runwith里申明使用PowerMockRunner，以下注解才能生效 @PrepareForTest：Mock静态、final、私有方法。 1@PrepareForTest(&#123; StringUtils.class,FirstSignInfoPullTask.class&#125;) @SuppressStaticInitializationFor(“org.moonzhou.test.XXXX”)：阻止静态代码块运行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@Componentpublic class RedisOperatorImpl implements RedisOperator &#123; protected static ShardedJedisClientImpl shardedClient; static &#123; shardedClient = new ShardedJedisClientImpl(&quot;redis.conf&quot;); &#125; @Override public String set(final String key, final String value) &#123; return shardedClient.execute(new ShardedJedisAction&lt;String&gt;() &#123; public String doAction(ShardedJedis shardedJedis) &#123; return shardedJedis.set(key, value); &#125; &#125;); &#125;&#125;// 测试类@RunWith(PowerMockRunner.class)@PrepareForTest(&#123; StringUtils.class&#125;)@SuppressStaticInitializationFor(&quot;com.suning.epp.member.fmsms.admin.common.RedisOperatorImpl&quot;)public class MockFirstSignInfoPullTaskTest &#123; @InjectMocks private FirstSignInfoPullTask firstSignInfoPullTask; @Mock private FmsmsIntegration fmsmsIntegration; @Mock private ApplicationProperties applicationProperties; @Mock private RedisOperatorImpl redisService; @Mock private FileUploadIntegrationImpl ossFileUploadIntegration; @Before public void init() &#123; MockitoAnnotations.initMocks(MockFirstSignInfoPullTaskTest.class); &#125; @Test public void test() &#123; PowerMockito.mockStatic(RedisOperatorImpl.class); PowerMockito.mockStatic(StringUtils.class); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;xxxxx&quot;); list.add(&quot;yyyyy&quot;); PowerMockito.when(applicationProperties.getTotalCount()).thenReturn(&quot;2&quot;); PowerMockito.when(applicationProperties.getStopRunning()).thenReturn(&quot;1&quot;); PowerMockito.when(redisService.get(&quot;firstSignFileCount&quot;)).thenReturn(&quot;0&quot;); PowerMockito.when(applicationProperties.getOssFileBucket()).thenReturn(&quot;memberattr_private&quot;); FileOSSResponse response = new FileOSSResponse(); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;arrayLists&quot;,list); response.setFile(jsonObject.toJSONString()); PowerMockito.when(ossFileUploadIntegration.downFileStream(Mockito.anyObject())).thenReturn(response); PowerMockito.when(StringUtils.transformUserInfosFromBase64Str(Mockito.anyString())).thenReturn(list); Map&lt;String, Object&gt; resMap = new HashMap&lt;String, Object&gt;(); resMap.put(&quot;responseCode&quot;,&quot;00000&quot;); PowerMockito.when(fmsmsIntegration.firstSignInfoPush(Mockito.anyMap())).thenReturn(resMap); firstSignInfoPullTask.firstSignInfoPullTask(); &#125;&#125; PowerMock里常用语法：Mock静态、final、私有方法时，需要加注解@PrepareForTest mock方法内部new出来对象 1PowerMockito.whenNew(XXX.class).withArguments(&quot;AAA&quot;).thenReturn(New XXX()); Mock普通对象的final方法： 12@PrepareForTestPowerMockito.mock(XXX.class) 12345678910111213141516171819202122//测试目标代码：public class Source &#123; public boolean callFinalMethod(SourceDepend refer) &#123; return refer.isAlive(); &#125;&#125;public class SourceDepend &#123; public final boolean isAlive() &#123; return false; &#125;&#125; //测试用例代码：@Test@PrepareForTest(SourceDepend.class)public void testCallFinalMethod()&#123; SourceDepend depencency = PowerMockito.mock(SourceDepend.class); Source underTest = new Source(); PowerMockito.when(depencency.isAlive()).thenReturn(true); Assert.assertTrue(underTest.callFinalMethod(depencency));&#125; Mock普通类的静态方法 12@PrepareForTestPowerMockito.mockStatic(XXX.class); 123456789101112131415161718//测试目标代码：public boolean callStaticMethod() &#123; return SourceDepend.isExist();&#125;public static boolean isExist()&#123; return false;&#125; //测试用例代码：@Test@PrepareForTest(SourceDepend.class)public void testCallStaticMethod() &#123; Source underTest = new Source(); PowerMockito.mockStatic(SourceDepend.class); PowerMockito.when(SourceDepend.isExist()).thenReturn(true); Assert.assertTrue(underTest.callStaticMethod());&#125; Mock 私有方法 123456@PrepareForTestXXX xxx = PowerMockito.mock(XXX.class);PowerMockito.when(xxx, &quot;privateMethod&quot;).thenReturn(aaa);// another way(no testing)// PowerMockito.verifyPrivate(new XXX()).invoke(&quot;privateMethod&quot;, 1, &quot;json&quot;, request); 12345678910111213141516171819//测试目标代码：public boolean callPrivateMethod() &#123; return isExist();&#125; private boolean isExist() &#123; return false;&#125; //测试用例代码： @Test@PrepareForTest(Source.class)public void testCallPrivateMethod() throws Exception&#123; Source underTest = PowerMockito.mock(Source.class); PowerMockito.when(underTest.callPrivateMethod()).thenCallRealMethod(); PowerMockito.when(underTest, &quot;isExist&quot;).thenReturn(true); Assert.assertTrue(underTest.callPrivateMethod());&#125; 总结 以上为实际开发过程中涉及到的mock方法写单元测试，覆盖代码逻辑的基本使用方法 尽量通过mock，覆盖每一个逻辑分支 方法返回一定要使用断言 参考 https://www.cnblogs.com/hunterCecil/p/5721468.html https://www.jianshu.com/p/69f3d6785ad8","categories":[{"name":"工程质量","slug":"工程质量","permalink":"https://moon-zhou.github.io/categories/工程质量/"}],"tags":[]},{"title":"Hexo添加标记和分类","slug":"Hexo添加标记和分类","date":"2019-09-08T13:49:34.000Z","updated":"2019-09-08T14:20:58.182Z","comments":true,"path":"2019/09/08/Hexo添加标记和分类/","link":"","permalink":"https://moon-zhou.github.io/2019/09/08/Hexo添加标记和分类/","excerpt":"背景 云笔记目录下的文章都放在根目录下，数量已经达到不太好维护的程度，统一做了目录的划分 个人博客里的内容也需要进行对应的分类","text":"背景 云笔记目录下的文章都放在根目录下，数量已经达到不太好维护的程度，统一做了目录的划分 个人博客里的内容也需要进行对应的分类 选择主题 登录hexo官网主题库 之前使用的是Anodyne，从设计风格上，本次选择了Yilia-plus 离线下载或者clone到hexo目录下的themes文件夹下 修改项目目录下_config.yml的主题(hexo\\_config.yml,注意yml配置文件，冒号后有空格) 1theme: yilia-plus 主题基本配置 进入主题文件夹，打开主题下的_config.yml(hexo\\themes\\yilia-plus\\_config.yml) 根据主题下的README，按步骤自定义配置，本次核心修改category配置 1234menu: 主页: / 文章: /archives 分类: /categories 添加category配置 创建“分类”选项(hexo项目根目录) 1hexo new page categories 第一步执行完，会在项目目录下\\source\\categories文件夹下生产index.md文档，对该配置文档进行编辑(必须编辑在front matter里，即双—之间，尤其设置type) 123456---title: 分类date: 2017-12-02 21:01:24type: &quot;categories&quot;comments: false--- 确认项目目录下_config.yml里的category目录配置 1category_dir: categories 修改每一个项目目录下source_posts里的每一个md文档（博客文章），在front matter里添加分类categories 123456---title: Git学习-小白不能忍之二date: 2019-06-23 17:23:34categories: - Git--- 重新生成静态网站博文，并验证 123hexo cleanhexo ghexo s 验证时发现，发布文件夹hexo\\public\\categories里已经有相关配置了，但是category页面是个空白。（Anodyne主题就不会有该问题，所以每一主题都已自己的一套配置项，每次切换都需要根据README进行一次对应的配置修改） 需要重新编辑\\source\\categories下index.md，添加layout配置 1234567---title: 分类date: 2017-12-02 21:01:24type: &quot;categories&quot;layout: &quot;categories&quot;comments: false--- 自定义layout 主题\\themes\\yilia-plus\\layout目录下新建categories.ejs，自带的categorie.ejs无法正常使用（报错） 1234567891011121314151617181920&lt;article class=&quot;article article-type-post show&quot;&gt; &lt;header class=&quot;article-header&quot; style=&quot;border-bottom: 1px solid #ccc&quot;&gt; &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt; &lt;%= page.title %&gt; &lt;/h1&gt; &lt;/header&gt; &lt;% if (site.categories.length)&#123; %&gt; &lt;div class=&quot;category-all-page&quot;&gt; &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h2&gt; &lt;%- list_categories(site.categories, &#123; show_count: true, class: &apos;category-list-item&apos;, style: &apos;list&apos;, depth: 2, separator: &apos;&apos; &#125;) %&gt; &lt;/div&gt; &lt;% &#125; %&gt;&lt;/article&gt; 主题themes\\yilia-plus\\source-src\\css目录下创建categories.scss样式文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.category-all-page &#123; margin: 30px 40px 30px 40px; position: relative; min-height: 70vh; h2&#123; margin: 20px 0; &#125; .category-all-title &#123; text-align: center; &#125; .category-all &#123; margin-top: 20px; &#125; .category-list &#123; margin: 0; padding: 0; list-style: none; &#125; .category-list-item-list-item&#123; margin: 10px 15px; &#125; .category-list-item-list-count&#123; color: grey; &amp;:before &#123; display: inline; content: &quot; (&quot; &#125; &amp;:after &#123; display: inline; content: &quot;) &quot; &#125; &#125; .category-list-item &#123; margin: 10px 10px; &#125; .category-list-count &#123; color: grey; &amp;:before &#123; display: inline; content: &quot; (&quot; &#125; &amp;:after &#123; display: inline; content: &quot;) &quot; &#125; &#125; .category-list-child &#123; padding-left: 10px; &#125;&#125; 在主题themes\\yilia-plus\\source-src\\css目录下main.scss文件里，引入该scss文件（在同一目录） 1@import &quot;./categories&quot;; js文件会实时生效，但是scss文件需要进行重新编译 进入主题目录themes\\yilia-plus执行npm install 生成目标文件npm run dist 如果安装很慢，请进行镜像设置；如果安装出错，请uninstall之后重试 配置完成后，重新生成网站内容，验证正常 123hexo cleanhexo ghexo s tags配置类似 总结 该主题需要自定义layout及样式 不同的主题，配置差异很大，需要根据README逐个配置 source下目录结构 123456├─categories│ └──index.md├─tags│ └──index.md└─_posts └──***.md public下目录结构 123456├─archives│ └─***├─categories│ └─***└─tags └─***","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://moon-zhou.github.io/categories/HEXO/"}],"tags":[]},{"title":"日常问题汇总-一","slug":"日常问题汇总-一","date":"2019-09-07T12:14:34.000Z","updated":"2019-09-08T14:11:46.122Z","comments":true,"path":"2019/09/07/日常问题汇总-一/","link":"","permalink":"https://moon-zhou.github.io/2019/09/07/日常问题汇总-一/","excerpt":"如果页面样式有缺，点击传送门 背景 日常如何保证系统能够健康的运行，必不可少的就是实时的系统监控及告警。日常的服务接口成功率和耗时监控，还有一个就是系统异常数/种类，异常的影响级别等维度的监控。为此公司每月必须对系统产生的异常进行分析、治理。","text":"如果页面样式有缺，点击传送门 背景 日常如何保证系统能够健康的运行，必不可少的就是实时的系统监控及告警。日常的服务接口成功率和耗时监控，还有一个就是系统异常数/种类，异常的影响级别等维度的监控。为此公司每月必须对系统产生的异常进行分析、治理。 异常一 java.util.concurrent.RejectedExecutionException: Task com.suning.epps.fmsms.application.service.manager.config.PushSignRemindConfServiceImpl$1@6d18166d rejected from java.util.concurrent.ThreadPoolExecutor@4749b88d[Running, pool size = 16, active threads = 16, queued tasks = 100, completed tasks = 0] 异常解释 线程池超过其提交任务执行的吞吐量，大量任务过来时，没有足够的线程来完成，导致部分任务被拒绝执行，返回异常给主线程。 发生场景 分布式任务job跑批：定时为特定用户进行消息推送 架构 后台系统选择符合的数据，调用服务系统提供的推送rpc接口 服务系统根据传来的用户，直接调用推送系统进行推送 架构原因：后台作为分布式job入口，只负责获取原始数据，具体的业务推送的运算逻辑，统一在服务端里进行处理。后台机器目前只有一台（备一台，无异常时不参与对外提供服务），服务端有三台（备三台），这样才能整体提高该系统机器的一个使用效率。 服务端接口： 定义了参数为用户id的列表，列表数为1000，即每一次调用向1000个用户提供提送 推送的结果无强事务性，为了提高接口的处理能力，使用了多线程对提交的用户进行异步推送 分布式job跑批开始时，后台系统将获取到的数据丢给rpc接口（服务端）时，瞬时的tps可能会很高，因此第二步使用的多线程不能由业务逻辑去创建和管理，该场景使用统一的线程池进行线程的管理。 异常分析 数据量过大，job在调用服务端时，循环获取现有的数据后，直接调用服务端接口，导致tps很高 服务端里的线程池设置的最大线程数为16，同时阻塞队里使用 的是ArrayBlockingQueue，队列大小设置为100，未显示设置拒绝策略（默认AbortPolicy）。 12345final BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;Runnable&gt;( 100);ExecutorService executor = new ThreadPoolExecutor(4, 16, 60L, TimeUnit.SECONDS, queue); 结合异常，显而易见，高tps下，线程池最大16个任务在执行，同时阻塞队列里有100个待执行任务，集群里的3台机器也无法完全处理完，使用拒绝策略，抛出异常给主线程，主线程只是记录了异常，并未做其他补偿操作，所以导致部分任务被丢弃。 治理方案 服务端：扩大了核心线程数和最大线程数，阻塞队列的大小。计算公式为： Nthreads = Ncpu * Ucpu * (1 + W / C) Ncpu为CPU数目，Ucpu为目标CPU的使用率（0~1），W/C为等待时间与计算时间的比率 后台： job跑批时，后端系统循环调用服务端接口时，设置每一次rpc接口调用里用户列表数据的大小可配置（分布式配置中心配置后实时生效） for循环批次组织用户数据调用rpc接口时，每调用一次，计算线程sleep 5秒，降低服务接口的tps job跑批方法里，加入跑批停止的开关（分布式配置中心配置后实时生效），防止异常过多时，降级掉该job 服务接口里，针对job跑批要有幂等的处理，跑完的数据实时记录跑批结果，如果job降级后再启动，防止重复推送的情况。 治理注意点 使用LinkedBlockingQueue，必须设置其队列大小，否则默认为Integer.MAX_VALUE，并发量突增时，可能会因为链队列的不停扩大，导致OOM，不仅当前的服务不可用，也使得这台机器的其他服务也因此跪了，如果tps高持续时间较长，down一台机器，压力就需要被其他机器分担，很容易导致整个集群挂了。所以ArrayBlockingQueue不需要修改，超过容量时，也仅仅是本服务丢掉了部分数据未进行推送。 123public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125; 关于LinkedBlockingQueue和ArrayBlockingQueue 数据结构：ArrayBlockingQueue采用的是数组作为数据存储容器，LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。 ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 1234567891011121314/** Current number of elements */private final AtomicInteger count = new AtomicInteger();/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock(); /** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition(); /** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock(); /** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition(); 其他 最近正在体系化多线程的相关技术，线程池也在里面，后续会逐步整理出来。 异常二 2019-08-26 09:09:26,604|RequestTaskExecutor-thread-66531|8818a82b50c14e0386121e3eb697ef03|INFO|FacadeLogInterceptor|exit methodName:SignFacadeImpl.execute,argument:{“responseCode”:”9999”,”responseMsg”:”\\n### Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: mycat_error:1213,data_node:10.100.234.114,sub_tbl:CHECK_IN_DETAIL_0032,Deadlock found when trying to get lock; try restarting transaction\\n### The error may involve defaultParameterMap\\n### The error occurred while setting parameters\\n### SQL: update check_in_detail set full_sign = ‘1’, last_update_time = now() where channel_page_code = ? and user_no = ? AND datediff(sign_time,now()) = 0\\n### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: mycat_error:1213,data_node:10.100.234.114,sub_tbl:CHECK_IN_DETAIL_0032,Deadlock found when trying to get lock; try restarting transaction\\n; SQL []; mycat_error:1213,data_node:10.100.234.114,sub_tbl:CHECK_IN_DETAIL_0032,Deadlock found when trying to get lock; try restarting transaction; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: mycat_error:1213,data_node:10.100.234.114,sub_tbl:CHECK_IN_DETAIL_0032,Deadlock found when trying to get lock; try restarting transaction”} 异常解释 clientA更新某一行数据时，事务还未提交，又有一个clientB来操作同一行数据，此时clientB就会进入等待状态，直到出现Deadlock。 发生场景及分析 用户操作完补签后，如果用户已经达到了某个指标，会设置一个标志位（阶段一满签） 客户端一个用户发起了多个相同的请求时，一个请求未结束再发起一个一样的请求 正常业务场景下，一个用户只会发起一个场景，出现该场景为用户快速点击了按钮，前端未做防并发控制，导致服务端同时接收到多个请求更新同一条数据 服务端接口未做防并发请求 治理方案 客户端按钮添加防并发处理，按钮点击完未正常放回前不可点击，设置可点击超时时间。 服务端接口做好防并发方式（分布式锁方案即可） redis缓存用户id+方法，过期时间大于一次方法执行的最大时间 setNx + expire（保证两个方法的原子性） 其他 分布式锁相关还在整理中。 其他问题 Mycat 问题 Mycat的默认情况下，如果代码里面开启的事务，Mycat如介入事务管理。如果代码里面出现数据库异常，Mycat就会认为事务需要rollback，但是如果此时我们catch掉该异常希望继续提交其他数据库事务操作（比如部分非重要操作，为了不影响主流程执行），Mycat会拒绝commit请求，此刻事务就处于未提交也未回滚的状态，会对其他数据库操作造成持续异常。 解决方案：关闭Mycat介入事务 1&lt;property name=&quot;txInterruptByMycat&quot;&gt;false&lt;/property&gt;","categories":[{"name":"问题记录","slug":"问题记录","permalink":"https://moon-zhou.github.io/categories/问题记录/"}],"tags":[]},{"title":"【朝花再拾】AOP-01","slug":"【朝花再拾】AOP-01","date":"2019-08-25T04:07:34.000Z","updated":"2019-09-08T07:52:39.237Z","comments":true,"path":"2019/08/25/【朝花再拾】AOP-01/","link":"","permalink":"https://moon-zhou.github.io/2019/08/25/【朝花再拾】AOP-01/","excerpt":"如果无法正确查看流程图， 点击传送门 背景最近在重新整理spring知识结构，从Springboot入手，在自定日志打印时，使用aop进行的处理。(详情见上一篇日志) 同时最近项目组招聘小伙伴时，问到过spring aop的相关问题。 因此觉得有必要由浅入深，把以前学习的落到文档上，方便自己的回顾，也便于传播。","text":"如果无法正确查看流程图， 点击传送门 背景最近在重新整理spring知识结构，从Springboot入手，在自定日志打印时，使用aop进行的处理。(详情见上一篇日志) 同时最近项目组招聘小伙伴时，问到过spring aop的相关问题。 因此觉得有必要由浅入深，把以前学习的落到文档上，方便自己的回顾，也便于传播。 AOP编程思考 通常使用java进行面向对象编程时，代码的执行都是按照时间序列纵向展开的（运行）：以方法调用作为基本执行单位展开的，将方法调用作为一个连接点，由连接点串起来的程序执行流程就是整个程序的执行过程。（每个方法运行时都会创建一个栈帧） aop与传统编程思维不同，它将每一个方法调用，即连接点作为编程的入口，针对方法进行编程。从执行的逻辑上来看，相当于在之前纵向的按照时间轴执行的程序横向切入。相当于将之前的程序横向切割成若干的面，即Aspect.每个面被称为切面。 AOP本质上是针对方法调用的编程思路。 AOP的产生方法的鉴权，打印方法的运行时间，传统的数据库操作方法（获取链接-&gt;执行sql-&gt;获取结果-&gt;提交事务-&gt;获取结果），这些场景里，需要针对方法做一些共性的操作，因此与aop编程思想十分契合。利用aop抽取方法的共性操作，方法本身无需关注，只需要关注自身的业务逻辑。 AOP的实现方式 静态代理：aspect 动态代理：JDK/cglib/Javassist/ASM 图解： 12345graph LR调用方--&gt;代理对象代理对象--&gt; 调用方代理对象--&gt;目标执行方法目标执行方法--&gt;代理对象 静态代理 含义 代理类通过实现与目标对象相同的接口，并在类中维护一个代理对象。通过构造器塞入目标对象，赋值给代理对象，进而执行代理对象实现的接口方法，并实现前拦截，后拦截等所需的业务功能。 优点：可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。(代理类的扩展本身就是业务逻辑的扩展，无需解耦或者某种程度说已经解耦) 缺点：因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增加方法，则目标对象和代理类都需要维护。 show github: 实现 测试 动态代理 因为静态代理可能会产生代理类的“爆炸”，是不是有什么方案可以不要写太多的代理类，因而引出动态代理： 框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。 JDK方式 在jdk1.3以后，jdk跟我们提供了一个API java.lang.reflect.InvocationHandler的类， 这个类可以让我们在JVM调用某个类的方法时动态的为些方法做些什么事。 版本1 思想：将目标执行的对象传入代理对象中，通过反射机制来执行目标对象的方法 实现 测试 版本2 思想：版本1里，代理时需要做的业务，在代理对象里完成的。因此需要将代理时的业务与代理本身进行解耦 实现 测试 缺点：在实际开发中，可能需要对没有实现接口的类（普通类）增强，用JDK动态代理的方式就没法实现。 cglib 介绍 cglib是一个开源库 在运行期扩展Java类与实现Java接口(Hibernate用它来实现ersistent Object 持久化对象的字节码的动态生成、Spring AOP框架) CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。 使用步骤 通过cglib动态代理获取代理对象Enhancer过程（类比Proxy） 设置业务逻辑处理类 设置回调对象，即执行intercept方法（拦截） 创建代理对象，与业务类相同，直接运行代理类的业务逻辑处理方法 V1版本核心：详情/测试 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * sub：cglib生成的代理对象 * method：被代理对象方法 * args：方法入参 * methodProxy: 代理方法 */@Overridepublic Object intercept(Object sub, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; // 可优化，见V2 System.out.println(&quot;cglib proxy before method...&quot;); Object result = methodProxy.invokeSuper(sub, args); // 可优化，见V2 System.out.println(&quot;cglib proxy after method...&quot;); return result;&#125;@Testpublic void testRun() &#123; // 代理类class文件存入本地磁盘方便我们反编译查看源码 Properties sourceCodePath = new Properties(); sourceCodePath.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;E:\\\\TestCode\\\\cglib\\\\v1&quot;); System.setProperties(sourceCodePath); // 通过cglib动态代理获取代理对象过程(类比JDK动态代理里的Proxy，但Enhancer更强大，既可以代理接口，也可以代理普通类，但不能拦截final方法) Enhancer enhancer = new Enhancer(); // 设置enhancer对象的父类，即业务类(需要被代理的类) enhancer.setSuperclass(CommonBiz.class); // 设置enhancer的回调对象 enhancer.setCallback(new CglibProxyV1()); // 创建代理对象 CommonBiz commonBizProxy = (CommonBiz) enhancer.create(); // 通过代理对象调用目标方法 commonBizProxy.execute();&#125; 与jdk动态代理的第一个版本类似，代理的处理业务逻辑需要与代理本身解耦，因此引出第二个版本 业务处理和代理处理逻辑都动态传入 intercept拦截处理业务逻辑，处理之前/之后的部分通过反射，先处理代理业务 核心代码：详情/测试 12345678910111213141516171819/** * sub：cglib生成的代理对象 * method：被代理对象方法 * args：方法入参 * methodProxy: 代理方法 */@Overridepublic Object intercept(Object sub, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; before(method); Object result; try &#123; result = methodProxy.invokeSuper(sub, args); &#125; finally &#123; after(method); &#125; return result;&#125; 参考 https://blog.csdn.net/weianluo/article/details/81607134 https://www.cnblogs.com/qf123/p/8671479.html https://blog.csdn.net/yhl_jxy/article/details/80633194","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://moon-zhou.github.io/categories/JAVA/"}],"tags":[]},{"title":"SB日志打印","slug":"SB日志打印","date":"2019-08-22T15:23:34.000Z","updated":"2019-09-08T07:52:01.935Z","comments":true,"path":"2019/08/22/SB日志打印/","link":"","permalink":"https://moon-zhou.github.io/2019/08/22/SB日志打印/","excerpt":"背景1. 为方便问题定位，每一次请求最好可以通过唯一的标识来串起每一个单独打印的日志 2. 正常的业务需求在sb框架里进行各业务逻辑层的拆分，传统的mvc分层，以及义务自定义的一些分层处理。因此公共的各层出入参需要打印且脱敏。","text":"背景1. 为方便问题定位，每一次请求最好可以通过唯一的标识来串起每一个单独打印的日志 2. 正常的业务需求在sb框架里进行各业务逻辑层的拆分，传统的mvc分层，以及义务自定义的一些分层处理。因此公共的各层出入参需要打印且脱敏。 请求日志连接方案 针对每一个controller请求，请求进入之前，设置唯一随机值，请求结束，删除该随机值。 使用logback提供的MDC扩展，设置每一次请求的invokeNo（“线程号”） 每一次通过logger.info输出日志的时候，都带上这个随机值。 show your myHub sb里实现拦截器HandlerInterceptor，设置线程号 https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-web/src/main/java/org/moonzhou/backend/base/web/interceptor/CommonInterceptor.java sb注册上拦截器 https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-web/src/main/java/org/moonzhou/backend/base/web/config/WebMvcConfig.java 配置logback，日志输出格式里添加上线程号的参数 https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-war/src/main/resources/logback-spring.xml 1[%X&#123;invokeNo&#125;] 分层日志打印方案 统一的各层拦截，标准日志输出 利用aop，针对各层特定的路径配置环绕通知 1234567891011121314/** * 切入点描述 这个是controller包的切入点 */@Pointcut(&quot;execution(public * org.moonzhou.backend.base.web.controller..*.*(..))&quot;)public void controllerLog() &#123;&#125;//签名，可以理解成这个切入点的一个名称/** * 环绕增强，相当于MethodInterceptor * 环绕controller */@Around(&quot;controllerLog()&quot;)public Object aroundController(ProceedingJoinPoint joinPoint) throws Throwable &#123;&#125; logback里配置分层日志的loggerName 12345&lt;logger name=&quot;ControllerLogger&quot; level=&quot;$&#123;monitor.log.level&#125;&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONTROLLER_APPENDER&quot; /&gt;&lt;/logger&gt;private static final Logger SERVICE_LOGGER = LoggerFactory.getLogger(&quot;ControllerLogger&quot;); 脱敏输出出入参 详情见LogAspect.java和logback-spring.xml：https://github.com/moon-zhou/SpringBoot_Backend_Modules 日志异步化 保持原有的append生成文件及backup规则 再配置异步化append，依赖原有的append 使用异步化的append 异步日志打印时，日志格式里的class和method以及line是无法正常打印的1234567891011121314151617181920212223242526272829303132333435&lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;&lt;appender name=&quot;ERROR_FILE_APPENDER&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] [%class] [%method] [%line] [%X&#123;invokeNo&#125;] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;constants &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt;&lt;/appender&gt;&lt;!-- error日志异步化 --&gt;&lt;appender name=&quot;ERROR_ASYNC_FILE_APPENDER&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;10240&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref=&quot;ERROR_FILE_APPENDER&quot; /&gt;&lt;/appender&gt; 自定义注解，针对某些方法，灵活的添加日志 自定义日志注解 编写aop拦截类，将自定义注解作为切点条件，拦截规则里，针对切点做实际的日志输出处理 使用method log annotation，放到具体的类上进行测试。 详情见MethodLog及AnnotationLogAspect：https://github.com/moon-zhou/SpringBoot_Backend_Modules 问题：如果方法上已经被aop增强调用了，则该方法下再去调用的方法，加上自定义日志注解是不会生效（类似问题） 1234567891011121314151617181920212223242526/** * 测试注解日志请求 * controller上直接使用MethodLog是始终都会生效的 * http://localhost:8881/backend-base/hello/testAnnotationLog.do * @return */@MethodLog(operationType = &quot;testType&quot;, operationName = &quot;testUser&quot;, description = &quot;测试注解日志&quot;)@RequestMapping(&quot;/testAnnotationLog&quot; + SystemConstants.REQUEST_SUFFIX)@ResponseBodypublic BaseDto testAnnotationLog() &#123; // 这个使用的是spring上下文里的对象去调用initReturn方法，所以initReturn方法上的methodLog注解会被AnnotationLogAspect的规则拦截 return BeanUtil.getBean(this.getClass()).initReturn(); // 此处调用方法，已经被拦截处理过，即被动态代理拦截了，再直接调用别的方法，是通过代理对象调用的，方法是不会被增强的，即initReturn方法上注解不会生效 // return initReturn();&#125; /** * 测试注解日志打印 * @return */@MethodLog(operationType = &quot;init&quot;, operationName = &quot;testUser&quot;, description = &quot;初始化controller返回值&quot;)public BaseDto initReturn() &#123; return new BaseDto();&#125;","categories":[{"name":"SpringBoot2.X","slug":"SpringBoot2-X","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/"}],"tags":[]},{"title":"【反思录】19年7月的一点思考","slug":"【反思录】19年7月的一点思考","date":"2019-08-13T08:56:34.000Z","updated":"2019-09-08T07:52:34.657Z","comments":true,"path":"2019/08/13/【反思录】19年7月的一点思考/","link":"","permalink":"https://moon-zhou.github.io/2019/08/13/【反思录】19年7月的一点思考/","excerpt":"从六月底开始，接到原始需求，要开发一个关于签到的项目。 项目从零开始，主要从会员中台偏向门户的开发组和多活项目组各抽调2人，组成4人开发小组，加上领导作为架构的角色加入，总共4.5人的开发小组成立。","text":"从六月底开始，接到原始需求，要开发一个关于签到的项目。 项目从零开始，主要从会员中台偏向门户的开发组和多活项目组各抽调2人，组成4人开发小组，加上领导作为架构的角色加入，总共4.5人的开发小组成立。 前期架构拆解需求功能，非核心功能，已有系统已经具备的能力，通通拆解出去，明确好各个系统的职责。经过大小数次的讨论，最终明确签到系统核心做签到处理，签到奖励通过任务平台系统进行规则触发，调用礼包/券等系统进行发放等（详情见《签到类需求的设计与思考》)）。这个过程完全体现除了架构的各方面能力，现有系统的业务理解，系统的边界电仪，沟通能力，业务抽象和拆解的能力。按领导的话说就是无非是待的时间长一点，见得多一点。举重若轻。 在系统边界定义的“漫长”过程中，大家一方面分析需求，讨论细节，完善开发设计方案。这也是一个挺痛苦的过程。之所以有这个感受，来源于之前的开发方式。作为会员中台的开发，开发的东西在业务层面来看还是相对来说比较靠底层的服务。所以以往的需求，拆解到我们这里的时候，基本已经成型了，基本上该明确的地方都已经明确了。因此还诞生了一个现象，开发的设计文档里，经常出现产品需求里的段落文字描述，有点量还不少（撇去开发设计文档偷懒的因素）。所以这一次接到的更靠近用户侧的需求时，没有了以往的那种舒适感。 除了业务的划分，系统的级别评估，规划也在架构的带领下进行着评估。 以上基本完成了前期的准备工作。 终于到了动手的时候，前端、服务端、后端搭建系统环境，编码，自测，联调，转测。本以为会平稳的按部就班的时候，总有些意外不期而至。 第一个问题出现在我负责的会员门户相关系统里，wap端有部分功能在易购app里被使用了，这部分需要进行安全改造。梳理涉及敏感信息的功能，表单/ajax提交时，参数都需要进行加密传输，711刚刚结束业务版本，714就得上线。为此我分出接近2天时间投入，周六配合测试全场景覆盖，定位和分析问题，因为wap也属于半前后端分离，且前端人力不够，周六只有我一人配合，整个过程也是非常繁忙，好在加密方案的实施没有什么问题，仅仅是场景的遗漏。周日小伙伴继续接力修改漏洞及上线发布。上线发布的过程也出现了一个bug，解版进行解决。这个改造也算是有惊无险的解决了。 没过两天，第二个问题又来了。fastjson低版本安全漏洞，需要进行升级，门户类系统优先，718之前完成。刚刚着手改完升级的jar包，给测试写完测试建议，又有摄像头使用权限提示的改造，所以统一压缩到一个版本，718发布。 期间的业务需求也随之往后，静默视频，一键绑卡等等等等。当然安全改造涉及金服所有系统，签到的下游系统开发所属系统也在改造之列，整体签到计划（联调、转测）往后移两天。这也为后面节奏的失控，埋下了一个小隐患。 除了涉及安全的紧急版本之外，另一个就是系统多活改造的项目了。没有签到项目的时候，也没有排正规的开发计划，都是我带着做。新项目来了，只能领到协调小伙伴来进行改造了，测试环境搭建和代码改造分别找了两个小伙伴在之前进度的基础上继续进行。因为人力的问题，这个过程有一个小伙伴离开，另一个小伙伴需要进行系统的交接，所以，两个小伙伴基本完成工作之后，又没有人投入。这时候领导只能将外部支援小伙伴协调回来，继续完成后续的测试环境的多活演练。这个期间，我也是基本上投入20%。 到七月中下旬的时候，也就是718之后，业务版本需求的堆积，协调回来做多活的小伙伴被分配到业务版本需求里，后续的演练和生产多活环境的搭建，都交由另外专门负责的小伙伴完成。其实从前面也可以看出，演练还是我们在配合，分析各种问题等等等，后续的生产上线估计还得接着投入。期间人力的多次变动，虽然划分明确了各自的任务，但实施的时候，真的能够像如理想中一样吗？肯定不是，别人不熟悉你的系统，你得说明系统的架构，代码结构，业务。尤其是前后人力变更太大，原先预估的投入最多10%，现在投入至少有25%。这必然影响新系统的开发。 新系统里担任技术经理和开发的角色，大致的职责就是控制好开发的进度，协调好各方问题的解决。然而，期间核心开发预估百分百投入，却因为客观原因需要频繁请假，基本上投入了60%，这也就造成了开发过程的最大风险。怎么办小伙伴内部消化，分别看他实现的功能，配合前端联调，下游rpc接口联调等等。内部消化了了怎么办，还是有交付风险，那就周末加班了。 因为系统的定位是签到系统，中心这个领域只有这一个系统，原先的签到只是固化在app里的一个功能，没有实现拆分。因此当会员中心签到需要改版时，相关后端服务接口自然而然就落在了我们系统了。且这部分开发人力没有在最初的工作计划里体现，且提出时，基本已经到了转测的时间。怎么办，协调人力，加班消化。 伴随着增加的工作计划，二期需求的如约而至，正常签到完之后，还需要有补签的功能，因为涉及到补签卡系统，需求发布时间不一致问题，整体的联调测试比一期往后延一个礼拜。因为前期本身工作的繁杂，原系统的问题，多活，新系统开发，小伙伴请假功能的配合联调，会员中心签到需求等等，导致二期补签工作联调延后，部分功能遗漏，需求变更没有及时关注等等。 刚刚加完班，把补签，新需求都开发自测完成。还有部分的分布式job实现，待下周继续。 总结如下： 人力永远都是一个问题。 缺乏备份小伙伴，bus factor风险很高。 在第二点的基础上，会造成临时组成的开发小组，小伙伴永远不可能理想型的完全投入，没有备份的前提下，需要花费相当的时间配合定位各种测试和生产，门户类系统尤为突出，直面用户，流量入口，也是问题入口。所以实际投入新系统开发时间不够只能自己消化。 临时组件团队开发的风险识别意识尤其要强，本身就存在磨合问题，小伙伴自身的问题要及时暴露。 带头人还是需要强势一点。 多任务交叉的时候，及时拆解，划分好相关责任人。 精益项目里也说过，开发担任项目经理角色没有测试，或者产品更合适，因为后两者更关注整体进度与质量（有专门项目经理的除外）。新系统是标准型项目，项目经理在这个过程中协调解决问题，消减了很大一部分的风险。专业的人做专业的事。 人力-计划-工作量-质量，需要维持好一个平衡。最后如果总需要各方来内部消化的话，肯定是有问题的。 当计划推着你不停往前赶的时候，难免会出现技术债，其实我们已经出现了。","categories":[{"name":"总结反思录","slug":"总结反思录","permalink":"https://moon-zhou.github.io/categories/总结反思录/"}],"tags":[]},{"title":"【奇技淫巧】SB里数据层的拓展及小技巧","slug":"【奇技淫巧】SB里数据层的拓展及小技巧","date":"2019-08-13T08:56:34.000Z","updated":"2019-09-08T07:52:32.317Z","comments":true,"path":"2019/08/13/【奇技淫巧】SB里数据层的拓展及小技巧/","link":"","permalink":"https://moon-zhou.github.io/2019/08/13/【奇技淫巧】SB里数据层的拓展及小技巧/","excerpt":"背景 JavaWeb里，基础的不复杂的业务系统，ORM框架通常都是直接使用。本文介绍数据层的扩展和小技巧。","text":"背景 JavaWeb里，基础的不复杂的业务系统，ORM框架通常都是直接使用。本文介绍数据层的扩展和小技巧。 mybatis generator 父pom里添加构建plugin管理，pluginManagement-plugins-plugin，添加mybatis-generator-maven-plugin（注意添加依赖的jar包，否则会报错），配置好generatorConfig.xml路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;build&gt; &lt;finalName&gt;XXX-$&#123;maven.build.timestamp&#125;&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources/config/$&#123;envName&#125;/&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.suning.epp.member.fmsms.admin.FmsmsAdminWebApplication&lt;/mainClass&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;project.basedir&#125;/src/main/resources/mybatis/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; dao子模块里使用该plugin 12345678910111213141516171819202122232425 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;*/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置generatorConfig.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt; &lt;!-- 一个数据库一个context --&gt; &lt;!--defaultModelType=&quot;flat&quot; 大数据字段，不分表 --&gt; &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;!-- &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot; /&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot; /&gt; --&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt; &lt;!-- 注释 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;&lt;!-- 是否取消注释 --&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否生成注释代时间戳--&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://10.243.59.148:3306/fmsmssit?serverTimezone=UTC&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&quot; userId=&quot;fabu&quot; password=&quot;cp1Y1Aa0E4Oo&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!--生成Model类存放位置--&gt; &lt;javaModelGenerator targetPackage=&quot;com.suning.epp.member.fmsms.admin.dmo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成Dao类存放位置--&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象 type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象 type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.suning.epp.member.fmsms.admin.dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名--&gt; &lt;table tableName=&quot;pit_manage&quot; domainObjectName=&quot;PitManage&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;true&quot; enableDeleteByExample=&quot;true&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;true&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;operation_record&quot; domainObjectName=&quot;OperationRecord&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;true&quot; enableDeleteByExample=&quot;true&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;true&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; IDEA里打开Maven Project视图，打开dao模块下的Plugins，即可看见mybatis-generator，双击执行mybatis-generator:generate 不同版本的SB，子模块引入plugin时，可能有的还需要配置resources，根据执行时候的实际情况，报错信息解决即可。 配置执行sql打印 在application.yml中添加下面配置，可以显示执行的sql语句 123logging: level: com.xxx.xxx.dao : debug 配置logback 1&lt;logger name=&quot;com.apache.ibatis&quot; level=&quot;debug&quot;/&gt; mybatis-plus 引入依赖(父pom进行管理，dao使用时引入) 123456 &lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus-boot-starter.version&#125;&lt;/version&gt;&lt;/dependency&gt; 修改yml配置 123456789#mybatis配置mybatis: mapper-locations: classpath*:mybatis/mapper/*Mapper.xml type-aliases-package: org.moonzhou.backend.base.dmo#mybatis-plus配置，仅一行不同mybatis-plus: mapper-locations: classpath*:mybatis/mapper/*Mapper.xml type-aliases-package: org.moonzhou.backend.base.dmo mybatis generator无法使用，只能使用mybatis-plus提供的generator 引入jar包 12345 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus-generator.version&#125;&lt;/version&gt;&lt;/dependency&gt; 代码修改相关配置 详细参考：https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-dao/src/test/java/org/moonzhou/backend/base/dmo/MybatisPlusGeneratorTest.java mybatis-plus分页（此处demo为手写sql的方式） mapper里，分页查询接口使用IPage page作为分页的条件 初始化时设置current和size 底层sql只需要关注原有的查询参数即可 selectUserByPageVo方法：https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-dao/src/main/java/org/moonzhou/backend/base/dao/mapper/UserMapper.java 多数据源的配置【TODO】 通过druid进行多数据源配置 通过sharding-jdbc进行多数据源的配置 通过360的Atlas实现Mysql的读写分离 代码示例 mybatis-generator示例github地址：https://github.com/moon-zhou/SpringBoot_Backend_Modules.git 参考 https://mp.baomidou.com/guide/page.html","categories":[{"name":"SpringBoot2.X","slug":"SpringBoot2-X","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/"}],"tags":[]},{"title":"sb2.0统一错误页面","slug":"sb2.0统一错误页面","date":"2019-08-13T08:43:34.000Z","updated":"2019-09-08T07:52:06.597Z","comments":true,"path":"2019/08/13/sb2.0统一错误页面/","link":"","permalink":"https://moon-zhou.github.io/2019/08/13/sb2.0统一错误页面/","excerpt":"背景调试mybatis-plus分页时，500错误，直接显示了原有的报错页。","text":"背景调试mybatis-plus分页时，500错误，直接显示了原有的报错页。 实操步骤 重写错误跳转 12345678910111213141516171819@Configurationpublic class ErrorConfigurar &#123; /** * SpringBoot2.0以上版本WebServerFactoryCustomizer代替之前版本的EmbeddedWebServerFactoryCustomizerAutoConfiguration * * @return */ //@Bean必须加上 @Bean public WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer() &#123; //第二种写法：java8 lambda写法 return (factory -&gt; &#123; ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/error.do&quot;); ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/error.do&quot;); factory.addErrorPages(errorPage404, errorPage500); &#125;); &#125;&#125; 自定义错误跳转（普通controller，用于给第一步跳转） https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-web/src/main/java/org/moonzhou/backend/base/web/controller/MyErrorController.java 编写第二步里的相关页面 https://github.com/moon-zhou/SpringBoot_Backend_Modules/tree/master/backend-base-war/src/main/webapp/templates/error","categories":[{"name":"SpringBoot2.X","slug":"SpringBoot2-X","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/"}],"tags":[]},{"title":"Maven中jar依赖冲突解决","slug":"Maven中jar依赖冲突解决","date":"2019-08-13T08:43:34.000Z","updated":"2019-09-08T07:52:08.613Z","comments":true,"path":"2019/08/13/Maven中jar依赖冲突解决/","link":"","permalink":"https://moon-zhou.github.io/2019/08/13/Maven中jar依赖冲突解决/","excerpt":"背景最近开了一个新系统开发，其中需要有个定时推送的业务，调用推送系统给手机推送相关消息。再接入推送系统的时候始终无法成功。","text":"背景最近开了一个新系统开发，其中需要有个定时推送的业务，调用推送系统给手机推送相关消息。再接入推送系统的时候始终无法成功。 分析与解决 推送系统以消息队列的方式对外提供服务（公司内部基于spring的jms开发的消息队列中间件），接入队列的过程中，提示始终无法创建队列的连接。 反馈相关错误给中间件系统，反馈是查下相关jar的版本。 排查过程中，发现依赖的消息队列的jar包有两个，一个时低版本，一个是高版本，初步怀疑是jar包冲突。 确认jar包冲突 下载maven构建的工程，确认最终打包里的依赖jar包版本，发现版本是较低的那个 从现有接入成功的项目工程里，发现是依赖的高版本jar包，99%确认 进行低版本排包 使用的idea（eclipse类似，dependency hierarchy视图） 多模块工程里，确认明确引入jar包的module 在该module下，打开依赖jar包视图：Ctrl+Alt+Shift+U或者打开View–&gt;Tool Windows–&gt;Maven Projects–&gt;Show Dependency，或者pom.xml右键Diagram–&gt;show dependency Ctrl+F查找jar包，确认该module下jar版本是否正常 确认该module下jar包是正常的，100%确认有其他jar包也依赖了spring的jms，逐个排查每一个module。重复第三第四步。 最后找到在相关module的依赖视图里找到了该jar的上游依赖 在上游依赖的jar包里spring的jms排掉即可 123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 验证 重新maven构建整个项目，在最后的war里确认最终的jar包版本，正常 重新发布，验证相关功能正常 意外 社区版是没有show dependency，使用mvn dependency:tree，查看各jar的依赖关系。","categories":[{"name":"Maven","slug":"Maven","permalink":"https://moon-zhou.github.io/categories/Maven/"},{"name":"问题记录","slug":"Maven/问题记录","permalink":"https://moon-zhou.github.io/categories/Maven/问题记录/"}],"tags":[]},{"title":"sb里正确使用logback的姿势","slug":"sb里正确使用logback的姿势","date":"2019-08-13T06:06:34.000Z","updated":"2019-09-08T07:52:04.398Z","comments":true,"path":"2019/08/13/sb里正确使用logback的姿势/","link":"","permalink":"https://moon-zhou.github.io/2019/08/13/sb里正确使用logback的姿势/","excerpt":"背景springboot里查看测试代码逻辑时，需要打印日志信息进行分析。","text":"背景springboot里查看测试代码逻辑时，需要打印日志信息进行分析。 实操步骤 因为Springboot已经引入了常用日志框架，logback，log4j，slf4j。所以无需再引入依赖，直接上手配置即可。（pom文件里，点击spring-boot-starter，进入starter的相关依赖xml，找到spring-boot-starter-logging，点击进入即可看到相关依赖） Spring Boot uses Commons Logging for all internal logging but leaves the underlying log implementation open. Default configurations are provided for Java Util Logging, Log4J2, and Logback. In each case, loggers are pre-configured to use console output with optional file output also available. By default, if you use the “Starters”, Logback is used for logging. Appropriate Logback routing is also included to ensure that dependent libraries that use Java Util Logging, Commons Logging, Log4J, or SLF4J all work correctly. from 官方api:https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/boot-features-logging.html#boot-features-logging-format 可以直接使用spring里的配置，也可以自定义使用。 使用spring里的配置 12345logging: level: org.moonzhou.backend.base.dao: debug org.moonzhou.backend.base.web.controller: warm file: logs/spring-boot-logging.log 自定义 application.yml添加如下配置 1logging.config=classpath:logback-spring.xml classpath下添加相关配置 https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-war/src/main/resources/logback-spring.xml logback配置xml里配置注意各个输出日志的文件级别 以上的配置里是固定的输出文件，更加灵活的特殊文件输出可使用logger进行配置，比如特殊的监控日志需要额外的打印到专有的监控文件，以便接入其他统计系统里【TODO-各层业务层监控日志及自定义日志】 测试 https://github.com/moon-zhou/SpringBoot_Backend_Modules/blob/master/backend-base-web/src/main/java/org/moonzhou/backend/base/web/controller/HelloController.java","categories":[{"name":"SpringBoot2.X","slug":"SpringBoot2-X","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/"}],"tags":[]},{"title":"签到类需求的设计与思考","slug":"签到类需求的设计与思考","date":"2019-08-12T15:23:34.000Z","updated":"2019-09-08T07:51:43.829Z","comments":true,"path":"2019/08/12/签到类需求的设计与思考/","link":"","permalink":"https://moon-zhou.github.io/2019/08/12/签到类需求的设计与思考/","excerpt":"背景6月底，所在会员研发中心接到原始需求，需要针对特定的频道开发签到功能。 基本要求： 1. 各频道签到页面可以动态配置 2. 各频道签到规则可不一致 3. 签到有每日奖品及累计奖品发放 4. 周期内可以通过补签卡进行补签 5. 补签和签到效果一致，发放对应奖品","text":"背景6月底，所在会员研发中心接到原始需求，需要针对特定的频道开发签到功能。 基本要求： 1. 各频道签到页面可以动态配置 2. 各频道签到规则可不一致 3. 签到有每日奖品及累计奖品发放 4. 周期内可以通过补签卡进行补签 5. 补签和签到效果一致，发放对应奖品 前期需求的讨论 动态配置页面的实现 了解现有的内容配置系统，看是否满足要求 确认现有内容管理不能完全满足，内容系统制管理内容 需要一个布局系统，整合内容管理的展示 签到奖励是通过谁来发送（功能落到哪个系统） 签到数据在签到系统 rpc调用任务平台发送签到奖励和补签奖励 补签卡的发放和使用 完成相关任务，不是直接调用券系统进行发放，而是通过任务平台–》礼包系统–》券系统 补签用卡 直接调用券系统 架构设计 后台配置管理系统 布局管理（和内容管理系统有关） 独立的文案配置（本质上也可以放到内容管理系统，但产品认为配置的任务文案，方便统一查看） 签到信息的查询和导出 补偿数据的查询 分布式job的实现：用户配置推送信息的job（上一篇全表扫描），补偿数据的job 服务系统的设计 开放签到等相关接口的rpc服务 rpc接口不局限于用户操作业务相关的，还包含job服务相关接口 通过网关进行包装 rpc只能是系统内网之间的通信服务，外部小程序或者H5只能通过http进行访问，需要金融网关对其进行一层包装，将rpc接口转换为http接口。 后端系统功能 整体采用springboot，包含两个代码库：springboot、vue vue代码库的最终打包文件放到springboot里 搭建过程可参考之前springboot+vue环境搭建 正常业务：频道管理，页面布局管理，以及补偿数据查询 job入口：用户推送消息job，签到失败补偿job（配置的到分布式任务平台，周期性调用） 服务端系统功能 签到类接口 查询签到信息接口（签到周期，每个用户展示的周期根据其实际签到进行计算，展示的不一定一样） 签到接口 不前接口 页面数据展示类接口 页面布局内容查询接口 轮播数据即可欧 用户配置类接口 查询定时提醒配置 修改定时提醒配置 job类服务接口 用户推送接口（后端系统调用该接口，再调用下游推送系统） 核心重大决策 签到接口 本签到系统数据落库成功，签到成功， 下游任务平台接口调用失败/超时的情况下，调用时的参数落补偿表，后台进行手动/job补偿。 任务平台的接口是幂等的，相同的参数调用不会频繁发送签到奖励。 任务平台调用风控时，如果认为是有风险的，即使补偿也无法成功，该情况只能等用户反馈后，由下游礼包等奖励系统，直接手动补偿。 补签接口 连续补签时，任务平台没有批量接口 业务上有系统，即签到系统，多线程批量调用，默认每一次单独补签为成功，调用超时/失败，补偿表进行处理 补签时是不会出现风控拦截的，因为补签卡发放时已经过了一到风控，能发送补签卡可定不会被拦截补签 用户消息推送 定时全表扫描（上一篇一次全表扫描XXXX） 筛选符合条件的数据 调用服务端接口进行推送（服务端调下游） 签到规则 会员中心 周期7天内，从未签过，打开时当天即为第一天 连续签7天即为满签 一旦有一天未签，重新从第一天开始签到 理财 周期7天内，从未签过，打开时当天即为第一天 七天之内均可签到，如有遗漏，在第七天结束之前均可以进行补签 前天周后，开始新的一轮，如果新一轮一直不签到，则每次打开，当天即为第一天 后期优化 job–》补偿次数可以优化为动态配置，否则达到补偿次数的数据一直占据着数据库的最前面，无法补偿。 补偿数据如果一直无法补偿，可以考虑再创建一个无法补偿的表存储，避免补偿表做过多的无用数据扫描 签到规则的提取，现在是if-else写死，后期可以抽取规则，根据条件注入，调用不同的规则实现 分析各层日志，接入紫金大盘进行接口调用量，成功率的统计分析 网关上接口的调用量和返回监控，是否需要配置上流控及返回文案 rsf接口关注tp99，耗时成功率等情况 思考 业务上的需求和最终实现上可能是矛盾的，需要进行互相的妥协。比如连续补签并发调用下游系统的相关决策。 保证数据的最终一致性","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://moon-zhou.github.io/categories/架构设计/"}],"tags":[]},{"title":"一次全表扫描关于分布式id的总结","slug":"一次全表扫描关于分布式id的总结","date":"2019-08-04T12:43:34.000Z","updated":"2019-09-08T07:52:44.016Z","comments":true,"path":"2019/08/04/一次全表扫描关于分布式id的总结/","link":"","permalink":"https://moon-zhou.github.io/2019/08/04/一次全表扫描关于分布式id的总结/","excerpt":"背景最近需要对某一个做了分表的数据，进行全表扫描做数据筛选后进行消息推送。设计思路 全表扫描时的筛选条件是什么 如何保证全表批量扫描时，每一批的数据量大致相同 确保可以全表扫描，没有数据的遗漏","text":"背景最近需要对某一个做了分表的数据，进行全表扫描做数据筛选后进行消息推送。设计思路 全表扫描时的筛选条件是什么 如何保证全表批量扫描时，每一批的数据量大致相同 确保可以全表扫描，没有数据的遗漏 实现 我们使用了Mycat来进行分库分表 分表字段为用户id 使用Mycat的sequence，来生成表的主键id，从而保证了所有表id的整体递增 固定每一次的数据量1000，按条件筛选后，批次处理数据量偏差不大，不会存在数据过大OOM的风险 知道总体的数据，从1~最后的数据，可以确保全表扫描 缺点 强依赖Mycat，Mycat依赖数据库的sequence配置表（实现方式） 数据落库时，id都需要通过Mycat获取sequence的当前值，作为数据的id，如果并发过高，对数据库的压力会比较大 配置表所在的Mysql宕机后，如果数据未及时同步，存在id重复的情况 总结以上的方案我们可以使用，是因为业务场景为扫描的用户配置信息，用户在设置操作时，不会存在高并发的情况，所以完全没有问题。（没有业务场景的方案设计，都是耍流氓）抽象/发散在高并发，分布式系统里，如何生成全局唯一、趋势递增的id相关场景 秒杀的业务场景下如何生成全局唯一、趋势递增的订单编号 基本要求 保证订单编号的生成逻辑要快、稳定，减少时延 保证生成的订单编号全局唯一、不重复、趋势递增、有时序性 实现方案 时间戳 [+ 机器码] + N位随机数流水号 缺点： 并发量高的场景，易出现重复id 数据库生成 规则：利用数据库（Mysql）的自增id，每一个表的初始值不一样，步长为分库/分表的数量（e.g. DB1-ID-(1,4,7…),DB2-ID-(2,5,8…),DB3-ID-(3,6,9…)） 缺点： 强依赖数据库，主从切换时的不一致可能会导致重复发号 性能及高可用瓶颈在数据库 redis 规则：利用 INCR 和 INCRBY这样的自增原子命令（Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的） 缺点： 单机存在性能瓶颈 集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。 优点： 性能比较高 生成的数据是有序的 其他注意点：为了避免长期自增后数字过大可以通过与当前时间戳组合起来使用，另外为了保证并发和业务多线程的问题可以采用 Redis + Lua的方式进行编码，保证安全。 雪花算法（snowflake-64bit） 规则：第一位固定0 + 41bit时间戳 + 10bit机器码 + 12bit序列号，10bit机器码还可以进行拆分为5bit数据中心标识 + 5bit机器标识 第1位占用1bit，其值始终是0，可看做是符号位不使用。 第2位开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是(1L&lt;&lt;41)/(1000L360024*365)=69 年的时间。 中间的10-bit位可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。 最后12-bit位是自增序列，可表示2^12 = 4096个数。 优点： ID是趋势递增 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高 生成ID的性能高（算法简单） 可以根据自身业务特性分配bit位，非常灵活 缺点： 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。直至时间被追回。 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package com.jajian.demo.distribute;/** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */public class SnowflakeDistributeId &#123; // ==============================Fields=========================================== /** * 开始时间截 (2015-01-01) */ private final long twepoch = 1420041600000L; /** * 机器id所占的位数 */ private final long workerIdBits = 5L; /** * 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** * 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** * 序列在id中占的位数 */ private final long sequenceBits = 12L; /** * 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** * 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** * 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** * 工作机器ID(0~31) */ private long workerId; /** * 数据中心ID(0~31) */ private long datacenterId; /** * 毫秒内序列(0~4095) */ private long sequence = 0L; /** * 上次生成ID的时间截 */ private long lastTimestamp = -1L; //==============================Constructors===================================== /** * 构造函数 * * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeDistributeId(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; // ==============================Methods========================================== /** * 获得下一个ID (该方法是线程安全的) * * @return SnowflakeId */ public synchronized long nextId() &#123; long timestamp = timeGen(); //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException( String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); &#125; //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; //毫秒内序列溢出 if (sequence == 0) &#123; //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; //时间戳改变，毫秒内序列重置 else &#123; sequence = 0L; &#125; //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) // | (datacenterId &lt;&lt; datacenterIdShift) // | (workerId &lt;&lt; workerIdShift) // | sequence; &#125; /** * 阻塞到下一个毫秒，直到获得新的时间戳 * * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) &#123; long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = timeGen(); &#125; return timestamp; &#125; /** * 返回以毫秒为单位的当前时间 * * @return 当前时间(毫秒) */ protected long timeGen() &#123; return System.currentTimeMillis(); &#125;&#125;// 测试代码public static void main(String[] args) &#123; SnowflakeDistributeId idWorker = new SnowflakeDistributeId(0, 0); for (int i = 0; i &lt; 1000; i++) &#123; long id = idWorker.nextId();// System.out.println(Long.toBinaryString(id)); System.out.println(id); &#125;&#125; 其他方案【TODO】 美团-idleaf 百度-UidGenerator 参考 https://juejin.im/post/5d36c112e51d455cd73ba169 https://juejin.im/post/5d22972f6fb9a07edd2a34cc","categories":[{"name":"分布式","slug":"分布式","permalink":"https://moon-zhou.github.io/categories/分布式/"},{"name":"方案设计","slug":"分布式/方案设计","permalink":"https://moon-zhou.github.io/categories/分布式/方案设计/"}],"tags":[]},{"title":"【Monkey Run】jquery 插件","slug":"【Monkey Run】jquery 插件","date":"2019-07-26T11:58:34.000Z","updated":"2019-09-08T07:52:41.639Z","comments":true,"path":"2019/07/26/【Monkey Run】jquery 插件/","link":"","permalink":"https://moon-zhou.github.io/2019/07/26/【Monkey Run】jquery 插件/","excerpt":"说明历史的技术栈，总结于四年前，从电脑的某个小角落发现。 jquery 扩展插件jQuery插件的开发包括两种： 类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数。 对象级别的插件开发，即给jQuery对象添加方法。","text":"说明历史的技术栈，总结于四年前，从电脑的某个小角落发现。 jquery 扩展插件jQuery插件的开发包括两种： 类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数。 对象级别的插件开发，即给jQuery对象添加方法。 一、类级别的插件开发类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。 1.1 定义一个全局函数jQuery.foo = function() { console.log(&apos;添加一个新的全局函数&apos;); }1.2使用extend定义全局函数jQuery.extend({ foo1:function() { console.log(&apos;extend 定义全局函数1&apos;); }, bar1:function() { console.log(&apos;extend 定义全局函数2&apos;); } });1.3 使用命名空间定义函数jQuery.plugin = { foo2:function() { console.log(&apos;使用namespace定义函数&apos;); } }调用方式$(function(){ $.foo(); // jQuery.foo(); $.foo1(); $.bar1(); $.plugin.foo2(); }); 二、对象级别的插件开发2.1 形式1(function($){ $.fn.extend({ foo3:function() { console.log(&apos;对象级别插件extend方式1&apos;); }, bar3:function() { console.log(&apos;对象级别插件extend方式2&apos;); } }) })(jQuery);2.2 形式2(function($){ $.fn.foo4 = function() { console.log(&apos;对象级别插件fn方式&apos;); } })(jQuery);上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突. 2.3 设置默认参数并对外暴露，保持私有方法/** * 私有方法 */ var privateFun = function(){ } function privateFun = function(){ } $.fn.simpleSwitch = function() { if (methods[method]) { return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); } else if (typeof method === &apos;object&apos; || !method) { return methods.init.apply(this, arguments); } else { $.error(&apos;Method &apos; + method + &apos; does not exist on jQuery.tooltip&apos;); } } /** * 默认的参数 */ $.fn.simpleSwitch.SIMPLESWITCH_DEFAULTS = { attr1: &quot;attr1&quot;, attr2: &quot;attr1&quot; }; 三、典型模板及解读// 传入了一个把公共变量“jQuery”传入了一个即时执行的函数里面，在函数局部（容器）中我们可以通过“$”来引用它 ;(function($) { // 局部作用域中使用$来引用jQuery // 在我们插件容器内，创造一个公共变量来构建一个私有方法 var privateFunction = function() { // 代码在这里运行 } // 通过字面量创造一个对象，存储我们需要的共有方法 var methods = { // 在字面量对象中定义每个单独的方法 init: function(options) { // 返回“this”（函数each（）的返回值也是this），以便进行链式调用。 return this.each(function() { var $this = $(this); var settings = $this.data(&apos;pluginName&apos;); if(typeof(settings) == &apos;undefined&apos;) { settings = $.extend({}, SIMPLESWITCH_DEFAULTS, options); $this.data(&apos;pluginName&apos;, settings); } else { settings = $.extend({}, settings, options); } // 代码在这里运行 // 例如： privateFunction(); }); }, destroy: function(options) { return $(this).each(function() { var $this = $(this); $this.removeData(&apos;pluginName&apos;); }); }, val: function(options) { var someValue = this.eq(0).html(); return someValue; }, onClick: function(){ }, offClick: function(){ }, click: function(){ } }; // 向jQuery中被保护的“fn”命名空间中添加你的插件代码，用“pluginName”作为插件的函数名称 $.fn.simpleSwitch = function() { // 检验方法是否存在 if (methods[method]) { /** * 在JS里Array是一个类 slice是此类里的一个方法 ，那么使用此方法应该Array.prototype.slice去截取参数 * 直白的方式为arrayObj.slice(start, [end])即[1,2,3].slice(1) * 等同于Array.prototype.slice.call([1,2,3], 1) */ return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); } else if (typeof method === &apos;object&apos; || !method) { // 如果方法不存在，检验对象是否为一个对象（JSON对象）或者method方法没有被传入 // 如果我们传入的是一个对象参数，或者根本没有参数，init方法会被调用 return methods.init.apply(this, arguments); } else { // 如果方法不存在或者参数没传入，则报出错误。需要调用的方法没有被正确调用 $.error(&apos;Method &apos; + method + &apos; does not exist on jQuery.tooltip&apos;); } /** * 关于call和apply都是调用方法，仅在参数arguments为数组时会有区别，如果调用的方法里的参数顺序与arguments一致，则使用apply，否则使用call */ } /** * 开关默认的参数 */ $.fn.simpleSwitch.SIMPLESWITCH_DEFAULTS = { }; })(jQuery); &lt;script type=&quot;text/javascript&quot;&gt; /*定义一个人类*/ function Person(name,age) { this.name=name; this.age=age; } /*定义一个学生类*/ function Student(name,age,grade) { Person.apply(this,arguments); Person.call(this,name,age); this.grade=grade; } //创建一个学生类 var student=new Student(&quot;zhangsan&quot;,21,&quot;一年级&quot;); //测试 alert(&quot;name:&quot;+student.name+&quot;\\n&quot;+&quot;age:&quot;+student.age+&quot;\\n&quot;+&quot;grade:&quot;+student.grade); //大家可以看到测试结果name:zhangsan age:21 grade:一年级 //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处. &lt;/script&gt; 四、总结和最佳做法 始终包裹在一个封闭的插件（即时执行的闭包里） 除非插件返回特定值（val），否则总是返回this关键字来维持chainability（jquery的链式编程） 传递一个可拓展的默认对象参数而不是大量的参数给插件（对插件进行抽象） 不要在一个插件中多次命名不同方法（不要出现下面的方式） (function($) { $.fn.tooltip = function(options) { // this }; $.fn.tooltipShow = function() { // is }; $.fn.tooltipHide = function() { // bad }; $.fn.tooltipUpdate = function(content) { // !!! }; })(jQuery); 始终命名空间的方法，事件和数据 参考：http://www.cnblogs.com/silverLee/archive/2009/12/22/1629925.htmlhttp://www.tuicool.com/articles/E3mEfeIhttp://www.cnblogs.com/Wayou/p/jquery_plugin_tutorial.htmlhttp://www.cnblogs.com/ellisonDon/archive/2012/08/12/2634503.htmlhttp://www.admin10000.com/document/9259.htmlhttp://blog.jobbole.com/30550/http://www.cnblogs.com/fromearth/archive/2009/07/08/1519054.htmlhttp://www.ibm.com/developerworks/cn/web/wa-jqplugin/#download","categories":[{"name":"前端","slug":"前端","permalink":"https://moon-zhou.github.io/categories/前端/"}],"tags":[]},{"title":"缓存那些事","slug":"缓存那些事","date":"2019-07-14T12:29:34.000Z","updated":"2019-09-08T07:51:49.237Z","comments":true,"path":"2019/07/14/缓存那些事/","link":"","permalink":"https://moon-zhou.github.io/2019/07/14/缓存那些事/","excerpt":"缓存那些事 缓存穿透 请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。 带来的风险：黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。 解决办法： 缓存空值：这些key对应的值设置为null或者空对象丢到缓存里面(过期时间) BloomFilter：查询缓存之前先过下布隆过滤器，有再去走CACHE–DB（False is always false, True is maybe true.） 总结： key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用BloomFilter。 空数据的key有限的，重复率比较高的，使用缓存空值。","text":"缓存那些事 缓存穿透 请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。 带来的风险：黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。 解决办法： 缓存空值：这些key对应的值设置为null或者空对象丢到缓存里面(过期时间) BloomFilter：查询缓存之前先过下布隆过滤器，有再去走CACHE–DB（False is always false, True is maybe true.） 总结： key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用BloomFilter。 空数据的key有限的，重复率比较高的，使用缓存空值。 缓存击穿 在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。 解决方案： 一般这种场景缓存的是公共资源，所以可以查库的操作可以加上互斥锁（分布式锁）。（查库的大操作里，再进行一次查缓存，防止大量请求没有获取到缓存时，都竞争这把锁排队，而第一个竞争到锁的线程查询完库之后又进行塞缓存，后续进程再查库之前时判断已查库就不需要进行真正的查库操作）（或者使用tryLock，失败重新进入，就不需要进行查库时也进行一次查缓存）（==同时需要注意不同key查询之间要互不影响==）。 热点数据不过期 缓存雪崩 当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。 解决方案 事前：使用集群缓存，保证缓存服务的高可用；参考第五点（过期时间不同） 事中：本地缓存 + 限流降级（ehcache + Hystrix） 事后：开启缓存持久化，尽快恢复集群（一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。） 总结 热点数据失效 在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。 解决方案： 设置不同的失效时间：在一个基础的时间上加上或者减去一个范围内的随机值（避免这些热点的数据集中失效）","categories":[{"name":"分布式","slug":"分布式","permalink":"https://moon-zhou.github.io/categories/分布式/"}],"tags":[]},{"title":"【小白踩坑】SpringBoot + VUE搭建过程发布问题整理","slug":"【小白踩坑】SpringBoot + VUE搭建过程发布问题整理","date":"2019-07-06T15:15:34.000Z","updated":"2019-09-08T07:52:29.926Z","comments":true,"path":"2019/07/06/【小白踩坑】SpringBoot + VUE搭建过程发布问题整理/","link":"","permalink":"https://moon-zhou.github.io/2019/07/06/【小白踩坑】SpringBoot + VUE搭建过程发布问题整理/","excerpt":"前言 从本场地环境搭建，启动，到发布服务器，时刻都可能存在着各种问题。雁过留痕，以此记录。","text":"前言 从本场地环境搭建，启动，到发布服务器，时刻都可能存在着各种问题。雁过留痕，以此记录。 后台搭建问题 本地环境搭建启动问题总结链接记录：请戳我 因为图床域名被收回，超链接为文本笔记，非md文档。 发布到服务器上，出现了两个问题（前提是本地可以正常启动，web容器使用的是jboss） 服务器压根无法启动 因为本地可以启动，服务器上的web容器却无法启动，猜测是web容器相关配置，查找资料，需添加如下配置： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 服务器正常启动，但controller却无法访问，ajax请求及页面跳转都无法正常返回，显示404。 因为请求都无法返回，猜测是controller都未被注册到spring上下文里面，查找相关资料，找到如下解决方案：继承SpringBootServletInitializer，重写configure方法 123456789101112131415@SpringBootApplication@MapperScan(&quot;com.suning.epp.member.fmsms.admin.dao&quot;)@ImportResource(locations = &#123;&quot;classpath*:config/sfops-ws-client.xml&quot;&#125;)public class FmsmsAdminWebApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(FmsmsAdminWebApplication.class); &#125; public static void main(String[] args) &#123; SpringApplication.run(FmsmsAdminWebApplication.class, args); &#125;&#125; ajax请求正常，跳转ftl页面出现404 确认是否引入了freemarker依赖 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 确认templates目录是否编译到classes下，如果是resources目录下回自动编译，如果是自定义目录下，需要手动设置该目录为resources 确认配置文件，尤其是template-loader-path 页面跳转也正常，但是资源文件（js/css）404 确认static-locations配置 前端页面搭建问题 因为把原先创建的vue工程复制到别的文件夹，导致无法再次build（npm 项目，在安装依赖node_modules的时候，会记录当前的文件路径。当路径更改，就无法正常启动。） 删除原有的node_modules 使用npm install install过程可能出现npm ERR! code: ‘EPERM’ (权限问题 errro permit)：npm cache clean –force 多次执行npm install，依然报错，且执行npm run dev，报‘webpack-dev-server’不是内部或外部命令错误，但是小伙伴新搭建的却没有这类问题，猜测可能和npm有关，更新至最新版：npm install -g npm 再次执行npm install，正常，出现 run npm audit fix to fix them, or npm audit for details可忽略 npm run dev测试正常 配置完prefix之后npm无法使用，参考【傻瓜式学Vue-01搭建环境、初始化项目】第三步，建议目录不要配置到node的安装目录【TODO】 删除C:\\Users{账户}\\下的.npmrc文件 跳转到ftl页面，但是js/css始终404，查看相关位置的文件都正常 源文件里点击js/css可以进入相关页面 浏览器F12，发现相关脚本文件的地址都正常，上下文根都正常（eg.http://localhost:8881/XXXX/assets/css/hello/app.9df0c078c59382db011d74ed17465dad.css） 此时猜测问题应该在配置上，网上查找相关配置，修改完访问正常。 123Spring: resources: static-locations: classpath:/","categories":[{"name":"SpringBoot2.X","slug":"SpringBoot2-X","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/"},{"name":"Vue","slug":"SpringBoot2-X/Vue","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/Vue/"},{"name":"问题记录","slug":"SpringBoot2-X/Vue/问题记录","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/Vue/问题记录/"}],"tags":[]},{"title":"【朝花再拾】Maven知识点","slug":"【朝花再拾】Maven知识点","date":"2019-07-06T15:15:34.000Z","updated":"2019-09-08T07:52:36.878Z","comments":true,"path":"2019/07/06/【朝花再拾】Maven知识点/","link":"","permalink":"https://moon-zhou.github.io/2019/07/06/【朝花再拾】Maven知识点/","excerpt":"背景 最近搭建SB系统时，是基于maven的project，常年没有搭建，有些知识点已经遗忘，在这个过程中，把相关东西一点点拾起来。","text":"背景 最近搭建SB系统时，是基于maven的project，常年没有搭建，有些知识点已经遗忘，在这个过程中，把相关东西一点点拾起来。 知识点 基本知识点：modules、parent、groupId、artifactId、version DepencyManagement与单纯的Dependencies DepencyManagement 由于是基于多模块进行的搭建，因此不同模块之间对第三方依赖的使用就需要进行规范，防止不同的模块对同一第三方依赖使用的版本不同，造成测试和发布的结果不一致问题。 父pom通过DepencyManagement-dependencies-dependency（groupId-artifactId-version）控制依赖以及版本 子module里pom通过dependencies-dependency（groupId-artifactId）直接使用，而不需要指定具体的版本号，直接依赖父pom的版本配置 父pom里还可以对version进行统一的配置提取管理，将依赖的version抽取到properties，定义变量，这样第三方依赖也被放到一起，更易于依赖版本的管理 单纯的Dependencies 相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承 区别 dependencies即使在子模块中不写该依赖项，那么子模块仍然会从父项目中继承该依赖项（全部继承） dependencyManagement里只是声明依赖，并不实现引入，因此子模块需要显示的声明需要用的依赖。如果不在子模块中声明依赖，是不会从父项目中继承下来的；只有在子模块中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子模块中指定了版本号，那么会使用子模块中指定的jar版本。（==当然一般不建议子模块里指定version==） 总结 dependencies中的jar直接加到项目中，管理的是依赖关系（如果有父pom,子pom,则子pom中只能被动接受父类的版本）； dependencyManagement主要管理版本，对于子类继承同一个父类是很有用的，集中管理依赖版本不添加依赖关系，对于其中定义的版本，子pom不一定要继承父pom所定义的版本。 scope dependency里引入scope，主要管理依赖的部署。配置值及使用如下: 概念 compile：缺省值，适用于所有阶段，会随着项目一起发布。 provided：类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime：只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test：只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system：类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 详解 compile （编译范围） compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。 provided （已提供范围） provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。 runtime （运行时范围） runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC test （测试范围） test范围依赖在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。 system （系统范围） system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。 packaging 默认是jar类型 pom：父类型都为pom类型 jar：内部调用或者是作服务使用 war：需要部署的项目 profiles：配合打包时，针对不同的环境取不同的配置。 每个profile都有唯一的id，也包含properties属性。id定义不同环境，properties设置变量。结合打包时build使用。 示例： 1234567891011121314151617181920212223242526&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;sit&lt;/id&gt; &lt;properties&gt; &lt;envName&gt;sit&lt;/envName&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pre&lt;/id&gt; &lt;properties&gt; &lt;envName&gt;pre&lt;/envName&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;uat&lt;/id&gt; &lt;properties&gt; &lt;envName&gt;uat&lt;/envName&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prd&lt;/id&gt; &lt;properties&gt; &lt;envName&gt;prd&lt;/envName&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 扩展：springboot也为我们提供了针对不同环境的打包方式，此处暂不进行示例演示。 build 分类 project Build：project 的直接子元素（子模块pom里） profile Build：profile的直接子元素（直观上就是父pom里，与profile配合使用） 相关配置 resources-resource-filtering： true/false，表示为这个resource，filter是否激活 pluginManagement:pluginManagement的配置和plugins的配置是一样的，只是用于继承，使得可以在孩子pom中使用。类比DepencyManagement 其他配置暂时不做详解。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;build&gt; &lt;finalName&gt;backend-base-$&#123;maven.build.timestamp&#125;&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources/config/$&#123;envName&#125;/&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;org.moonzhou.backend.base.BackendBaseWebApplication&lt;/mainClass&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt;&lt;!--子模块--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 常用命令 mvn compile 编译,将Java 源程序编译成 class 字节码文件。 mvn test 测试，并生成测试报告 mvn clean 将以前编译得到的旧的 class 字节码文件删除 mvn pakage 打包,动态 web工程打 war包，Java工程打 jar 包 mvn install 将项目生成 jar 包放在仓库中，以便别的模块调用","categories":[{"name":"Maven","slug":"Maven","permalink":"https://moon-zhou.github.io/categories/Maven/"}],"tags":[]},{"title":"SpringBoot + VUE系统搭建","slug":"SpringBoot + VUE系统搭建","date":"2019-06-30T11:43:34.000Z","updated":"2019-09-08T07:51:59.501Z","comments":true,"path":"2019/06/30/SpringBoot + VUE系统搭建/","link":"","permalink":"https://moon-zhou.github.io/2019/06/30/SpringBoot + VUE系统搭建/","excerpt":"学前准备 有java web开发经验，熟悉MVC开发 了解前端页面编写 了解前后端数据交互","text":"学前准备 有java web开发经验，熟悉MVC开发 了解前端页面编写 了解前后端数据交互 背景 新项目开始，搭建后台系统，采用伪前后端分离（前端代码剥离，但最终依然需要加入到后端系统，通过后端容器进行发布） 目标拆分 后端系统搭建-SpringBoot 新建SpringBoot项目 配置多模块 各模块设计可参考github demo各模块README说明 各模块引入相关jar包 明确各模块依赖 配置打包环境 启动 功能测试 编写Controller，测试Controller层（ajax-json接口） 编写Service，测试Controller-Service 编写dao层，引入ORM框架（mybatis），测试Controller-Service-service 测试约定的application.yml配置 测试自定义yml配置 接入Freemarker，测试Controller页面跳转 前端系统搭建-VUE 环境搭建及初始化==参考傻瓜式学VUE系列== 固定数据测试 使用Element-UI，通过固定数据加载，初始化列表组件 打包，集成至后端系统，通过Controller进行测试 动态数据测试 调用后端固定接口，按返回数据初始化列表组件 打包，集成至后端系统，通过Controller加载页面，通过前端调用后端接口的数据来初始化组件 小白踩坑 初始创建为非maven项目，后续多模块无法依赖是，idea里右键选择Add Framework Support，选择maven即可。 入口main函数上加上@EnableAutoConfiguration，这样各个依赖的module里的注解才能正常被spring识别，加入spring上下文中进行管理。 注意各个包的定义，最终打包的文件，入口函数要在最外面，否则即使加了自动配置注解，也无法扫描到包外的spring注解类。 java.sql.SQLException: The server time zone value：数据库连接加上serverTimezone=GMT，eg.jdbc:mysql://localhost:3306/member?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT 该异常不同版本的springboot不一定都会出现，2.1.6出现单2.0.2没有该异常 持久层接口类加入spring上下文进行管理 接口类上加Mapper注解，类似service类上加Service注解 main类上加MapperScan注解，扫描持久层接口类所在的包，eg.@MapperScan(“org.moonzhou.backend.base.dao”) 自定义yml时无法被自动识别问题 @PropertySource该注解老版本支持，1.0.4之后该属性就取消了 2.0.0官方解释：YAML files cannot be loaded by using the @PropertySource annotation. So, in the case that you need to load values that way, you need to use a properties file. 使用@Configuration-@Bean，通过代码将自定义的yml文件加入spring上下文管理里，通过@Value或者@ConfigurationProperties来进行配合使用 小白不能忍 创建的配置文件为properties文件，代码最终都是人看的，yml配置跟易于开发人员进行阅读，本人建议使用yml格式进行配置。该配置需要注意： 冒号之后需要空一格，再写配置值 必须要有自定义配置的配置文件，尽量根据功能不同抽取出不同的配置文件。至少自定义的配置与框架类配置进行抽离。 http请求默认后缀配置 配置yml（也可以通过代码） 1234567spring: mvc: pathmatch: use-suffix-pattern: false use-registered-suffix-pattern: true contentnegotiation: favor-path-extension: false 代码修改，添加到main类中 123456789101112/** * 设置匹配.do后缀的请求 * * @param dispatcherServlet * @return */@Beanpublic ServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean bean = new ServletRegistrationBean(dispatcherServlet); bean.addUrlMappings(&quot;*.do&quot;); return bean;&#125; 导致问题：静态资源都无法正常访问-404 退而求其次，抽取公共后缀，手动加在RequestMapping的value后面 配置热启动 父pom添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 如果想让模板页面也生效，需要修改相关模板缓存未false（这一步改为true也生效了，实操时各自看） 123spring.thymeleaf.cache=falsespring.freemarker.cache=falsespring.groovy.template.cache=false yml配置，按需配置(https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html) 12345# 热启动devtools: restart: enabled: true additional-paths: src/main/java 配置idea 快捷键Ctrl+Alt+S打开设置(File-&gt;settings)，在Build，Execotion，Deployment-&gt;Compiler-&gt;勾选Build Project automatically项 快捷键Ctrl + Shift + Alt + /，选择Registry，勾选 Compiler autoMake allow when app running 上述配置结束，重启应用，当改动代码时，观察控制台输出，你会发现Spring Boot已经检测到了文件变化，并重新启动。 配置Druid数据源(https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter) 添加依赖 12345 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt;&lt;/dependency&gt; 修改yml数据源配置 123spring: datasource: type: com.alibaba.druid.pool.DruidDataSource 添加监控配置 123456789101112spring: datasource: druid: web-stat-filter: enabled: true url-pattern: /* web-stat-filter.exclusions: .js,.gif,.jpg,.png,.css,.ico,/druid/* stat-view-servlet: enabled: true url-pattern: /druid/* login-username: druid login-password: druid123 监控测试 http://localhost:8881/backend-base/druid/index.html 抽象代码示例 github地址：https://github.com/moon-zhou/SpringBoot_Backend_Modules.git 本地启动：http://localhost:8881/backend-base/hello/test.do","categories":[{"name":"SpringBoot2.X","slug":"SpringBoot2-X","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/"},{"name":"Vue","slug":"SpringBoot2-X/Vue","permalink":"https://moon-zhou.github.io/categories/SpringBoot2-X/Vue/"}],"tags":[]},{"title":"Git学习-小白不能忍之一","slug":"Git学习-小白不能忍之一","date":"2019-06-23T09:23:34.000Z","updated":"2019-09-08T07:52:17.502Z","comments":true,"path":"2019/06/23/Git学习-小白不能忍之一/","link":"","permalink":"https://moon-zhou.github.io/2019/06/23/Git学习-小白不能忍之一/","excerpt":"背景 git 命令过长，记忆以及输入时不够快捷，不能忍 Git Log的进阶使用 Git查看日志，单独使用git log来操作，每一个commit信息太多，干扰信息又太多，而且各种分支的合并也看不到。优化如下： git log –graph –pretty=format:’%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative","text":"背景 git 命令过长，记忆以及输入时不够快捷，不能忍 Git Log的进阶使用 Git查看日志，单独使用git log来操作，每一个commit信息太多，干扰信息又太多，而且各种分支的合并也看不到。优化如下： git log –graph –pretty=format:’%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative 别名的使用：alias git config –global alias.ck checkoutgit config –global alias.br branchgit config –global alias.cm commitgit config –global alias.st status 配置之后，原来的git checkout直接使用git ck即可。==alias.xx==点后面的xx就代表了我们设置的别名。 结合别名的特性，我们可以优化第一点里的log以提高上述代码的效率。配置如下： git config –global alias.lg “log –graph –pretty=format:’%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative” 常用技巧 功能 快捷键 复制 ctrl + insert 粘贴 shift + insert 看日志 回车-查看更多，q-退出查看 merge后commit linux模式：”i”进入编辑模式，”ESC”退出编辑模式，”:” + “wq”退出并保存 组合命令 原始命令 组合命令 git add git commit git commit -a -m 也可以简写为 git commit -am","categories":[{"name":"Git","slug":"Git","permalink":"https://moon-zhou.github.io/categories/Git/"}],"tags":[]},{"title":"Git学习-小白实操","slug":"Git学习-小白实操","date":"2019-06-23T09:23:34.000Z","updated":"2019-09-08T07:52:15.565Z","comments":true,"path":"2019/06/23/Git学习-小白实操/","link":"","permalink":"https://moon-zhou.github.io/2019/06/23/Git学习-小白实操/","excerpt":"配置 Git 查看当前用户（global）配置信息：git config –global –list 修改配置信息：git config –global user.name moon-zhougit config –global user.email “ayimin1989@163.com“ 删除配置：git config –global –unset XXX","text":"配置 Git 查看当前用户（global）配置信息：git config –global –list 修改配置信息：git config –global user.name moon-zhougit config –global user.email “ayimin1989@163.com“ 删除配置：git config –global –unset XXX 查看 已commit但是未push的状态查看 git status #只能查看未传送提交的次数 git cherry -v #只能查看未传送提交的描述/说明 git log master ^origin/master #则可以查看未传送提交的详细信息 代码提交步骤 git add . #提交未跟踪、修改和删除文件 git commit -m ‘commit message’ git push origin remoteBranchXXXX 后悔药系列 本地commit之后，发现提交log填写错误，通过以下操作进行回退： git commit –amend 按下字母键 c（此时进入编辑状态），可以开始修改注释信息了 修改完成之后，按下Esc (退出编辑状态)； 接着连按两次大写字母Z，保存好退出（wq） 代码回退 git reset –hard commit_id #退到 指定commit的sha码 git reset –hard HEAD^ #回退到上个版本 git reset –hard HEAD~3 #回退到前3次提交之前，以此类推，回退到n次提交之前 以上做完，需要强推到远程：git push origin HEAD –force ==强推需要注意，当前分支不能是保护分支== git add之后，发现添加错了文件，使用git reset进行回退 git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了 修改了文件，但又不想add，想以远程分支为准。 git checkout . # 撤销对所有已修改但未提交的文件的修改，但不包括新增的文件 git checkout filename # 撤销对指定文件的修改，filename为文件名 分支操作 代码库确认git remote -v 查看分支与远程分支追踪状态git branch -vv 展示代码库下远程所有分支git branch -a 查看本地的git分支git branch 查看所有远程分支git branch -r 本地分支切换git checkout branchNameXXX 删除远程分支git push origin –delete remoteBranchName 删除本地分支git branch -d 不能在当前分支（如在master分支使用该命令，删除其他分支） 实际操作案例 一个迭代版本之后，旧分支合并master，同时删除旧分支，同时拉了新分支，如何进行操作，保持本地分支与远程分支的一致性。 查看远程分支：git branch -r 查看本地分支：git branch 或者使用git branch -a，查看本地和远程所有分支，比较出本地仓库和远程仓库的分支差异之后。进行如下操作。 获取远程仓库的新分支以及删除远程仓库已删除的分支:git fetch -p 获取远程新拉的分支（创建新分支并立即切换到新分支）：git checkout -b 或者 git checkout -b 本地分支名 origin/远程分支名 newBranchNameXXXX 拉取远程新拉分支的代码：git pull origin newBranchNameXXXX或者将本地分支与远程分支关联后直接pull： git branch –set-upstream-to=origin/RemoteBranch LocalBranch 因为已经发布，删除本地之前版本分支：git branch -D oldBranchNameXXX # 该命令不能在当前分支上删除当前分支，-D和-d有区别 其中5和6可以使用==git checkout -b localBranchName origin/remoteBranchName==(在本地新建分支，并自动切换到该本地分支。采用此种方法建立的本地分支会和远程分支建立映射关系)。同理也可以使用==git fetch origin remoteBranchName:localBranchName==（使用该方式会在本地新建分支，但是不会切换到该本地分支，需要手动checkout切换。采用此种方法建立的本地分支不会和远程分支建立映射关系。）+==git branch -u origin/remoteBranchName==（将当前分支映射到远程的指定分支，注意切换到当前分支；本地分支和远程分支建立映射时，两个名字不一定要一样） 不同分支之间进行合并：dev分支为公共的开发版本分支，ft分支为各自的编码分支，ft分支push之后，如何合并到dev分支，步骤如下： 切换到dev分支：git checkout devBranch 拉取dev分支代码：git pull 将ft分支合并到dev分支：git merge ftBranch 解决冲突：&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记冲突，删除不需要的部分即可。 解决冲突之后，重新commit-push。 demo说明： 123A-----C----E (&quot;stable&quot;) \\ B-----D-----F (&quot;new-idea&quot;) * git checkout stable # Change to work on the branch &quot;stable&quot; * git merge new-idea # Merge in &quot;new-idea&quot; * 做完上述两步得到如下结果： 123A-----C----E----G (&quot;stable&quot;) \\ / B-----D-----F (&quot;new-idea&quot;) * 要是你继续在“new idea” 和“stable”分支提交, 会得到： 123A-----C----E----G---H (&quot;stable&quot;) \\ / B-----D-----F----I (&quot;new-idea&quot;) * 因此现在A, B, C, D, E, F, G 和 H 属于 “stable”，而A, B, D, F 和 I 属于 “new-idea”。 切换分支后获取更新时的意外情况：先checkout切换分支，再pull 可能出现错误：Git pull - Please move or remove them before you can merge 如果多人提交时，别人先提交，自己本地修改了代码(相同的文件行)，然后pull时，会报error: Your local changes to the following files would be overwritten by merge: 如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来） git stash git pull origin master git stash pop 如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull git reset –hard git pull origin master 如果没有冲突，先pull后push之后，代码的提交分支就会看上去很乱，不是一条干净的直线。pull完之后rebase再提交即可把分叉的提交变成一条直线。 git pull git rebase git push 如果只在一条主分支上开发，忽然意识到这可能不太合适，需要一个在一个开发分支进行相关修改，步骤如下： 主分支 1234last version from another repository | v M---N-----O----P---Q (&quot;master&quot;) 把变更后的OPQ拆到新分支上 12345678910111213141516171819202122git branch dubious-experiment M---N-----O----P---Q (&quot;master&quot; and &quot;dubious-experiment&quot;) git checkout master # Be careful with this next command: make sure &quot;git status&quot; is # clean, you&apos;re definitely on &quot;master&quot; and the # &quot;dubious-experiment&quot; branch has the commits you were working # on first... git reset --hard &lt;SHA1sum of commit N&gt; (&quot;master&quot;) M---N-------------O----P---Q (&quot;dubious-experiment&quot;) git pull # Or something that updates &quot;master&quot; from # somewhere else... M--N----R---S (&quot;master&quot;) \\ O---P---Q (&quot;dubious-experiment&quot;) https://www.jianshu.com/p/3be4029ce854https://www.oschina.net/translate/git-fetch-and-merge?cmphttps://www.cnblogs.com/flying_bat/p/3408634.html","categories":[{"name":"Git","slug":"Git","permalink":"https://moon-zhou.github.io/categories/Git/"}],"tags":[]},{"title":"github新增代码库实操","slug":"github新增代码库实操","date":"2019-06-23T09:23:34.000Z","updated":"2019-09-08T07:52:26.805Z","comments":true,"path":"2019/06/23/github新增代码库实操/","link":"","permalink":"https://moon-zhou.github.io/2019/06/23/github新增代码库实操/","excerpt":"git创建新的代码库 登录github 找到”new repository”","text":"git创建新的代码库 登录github 找到”new repository” 本地操作 创建git目录：进入目录，git init 将所有文件添加到本地工作区：git add . 提交到本地库：git commit -m 提交说明 添加本地和远程仓库的关联：git remote add localRepositoryName remoteRepositoryUrl【示例：git remote add my-project-first https://github.com/moon-zhou/VueDemo.git】 第一次不需要pull，直接push，需要设置upstream，后面就直接push，git push –set-upstream my-project-first master 后悔药系列 如果github上传时，设置的提交人名称有误 删除上一次提交，如果就一次提交，或者只有一个作者，因为换机器导致提交用户错误的，直接删除代码库，重新新建github代码库 本地删除git管理文件：rm -rf .git 修改本地的git用户名：git config –global user.name，==详情参考Git学习实操== 重新参考”本地操作”，重新走一遍","categories":[{"name":"Git","slug":"Git","permalink":"https://moon-zhou.github.io/categories/Git/"}],"tags":[]},{"title":"Git学习-小白不能忍之三","slug":"Git学习-小白不能忍之三","date":"2019-06-23T09:23:34.000Z","updated":"2019-09-08T07:52:19.790Z","comments":true,"path":"2019/06/23/Git学习-小白不能忍之三/","link":"","permalink":"https://moon-zhou.github.io/2019/06/23/Git学习-小白不能忍之三/","excerpt":"","text":"背景 使用git命令pull/push代码时，总是需要输入用户名密码 频繁输入–》不能忍 是否可以保存账密不需要每次都输入 解决方案 git config –global credential.helper store 执行上述命令后，第一次pull或push需要输入用户名和密码，之后就不用再输入了。","categories":[{"name":"Git","slug":"Git","permalink":"https://moon-zhou.github.io/categories/Git/"}],"tags":[]},{"title":"Git学习-小白不能忍之二","slug":"Git学习-小白不能忍之二","date":"2019-06-23T09:23:34.000Z","updated":"2019-09-08T07:52:23.247Z","comments":true,"path":"2019/06/23/Git学习-小白不能忍之二/","link":"","permalink":"https://moon-zhou.github.io/2019/06/23/Git学习-小白不能忍之二/","excerpt":"背景 代码在idea里，会被自动编译，生成很多编译代码及IDE配置文件，在git目录下总是提示需要提交，不能忍","text":"背景 代码在idea里，会被自动编译，生成很多编译代码及IDE配置文件，在git目录下总是提示需要提交，不能忍 git在idea里的使用安装gitignore 在线安装 File–settings–Plugins–Browse Repositories 离线安装 下载地址：https://plugins.jetbrains.com/plugin/7495--ignore File–settings–Plugins–Install plugin from disk 新增.gitignore文件 new–.ignore file–.gitignore file(Git) 创建完成，添加忽略git跟踪的文件 错误处理 Git Pull Failed: Authentication failed for ‘http://git.XXX.git/&#39; 处理方式一：控制面板-凭据管理器-普通凭据，找到git:http://git.XXX.com的配置，修改用户名密码 如果第一步不生效，清空idea保存的账号密码：File–Settings–Appearance&amp;Behavior–System Settings–Password(清空设置或者不保存即可) 多分支切换时提示（git checkout branchName）：Your branch and ‘origin/Hot_Br_20190513’ have diverged,and have 181 and 7 different commits each, respectively. (use “git pull” to merge the remote branch into yours) 解决方案：You will have to reset to that remote branch in order to reset your local branch to it. git fetch origin git reset –hard origin/remoteBranchName 问题原因： 本地工作区里的代码提交进度与远程仓库的进度不一致 另外的解决方案 Git出现冲突error: Your local changes to the following files would be overwritten by merge: xxx/xxx/xxx Please, commit your changes or stash them before you can merge. Aborting 出现这个问题的原因是其他人修改了xxx并提交到版本库中去了，而你本地也修改了xxx，这时候你进行git pull操作就好出现冲突了。 解决方案：通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改 git stash git pull git stash pop 辅助命令 git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。 git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。","categories":[{"name":"Git","slug":"Git","permalink":"https://moon-zhou.github.io/categories/Git/"}],"tags":[]},{"title":"Git学习-小白学理论","slug":"Git学习-小白学理论","date":"2019-06-23T09:23:34.000Z","updated":"2019-09-08T07:52:13.382Z","comments":true,"path":"2019/06/23/Git学习-小白学理论/","link":"","permalink":"https://moon-zhou.github.io/2019/06/23/Git学习-小白学理论/","excerpt":"文件状态（未进行commit操作之前，存在三种状态） Untracked files Changes not staged for commit Changes to be committed","text":"文件状态（未进行commit操作之前，存在三种状态） Untracked files Changes not staged for commit Changes to be committed Untracked files 新增/删除的文件（除了新增和删除实际的动作，还包括修改文件名）。通常是某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件，编译文件，IDE生成的文件等。如果是需要提交的文件，则使用git add进行添加，将文件包含到待提交清单中（暂存区）。 删除这里的文件 12345678910111213# 删除 untracked filesgit clean -f # 连 untracked 的目录也一起删掉git clean -fd # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）git clean -xfd # 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfdgit clean -nfgit clean -nfd 添加.gitignore #为注释 可以使用shell所使用的正则表达式来进行模式匹配 匹配模式最后跟”/“说明要忽略的是目录 使用！取反（例如目录中包含 test.a，并且gitignore文件中包含 *.[oa]，如果在文件中加入 ！test.a 表明忽略除test.a文件以外的后缀名为.a或者.o的文件） 回退：git reset –hard Changes not staged for commit 修改的文件，但是还没有放入暂存区域，也就是没生成快照。（git add放入暂存区） Changes to be committed 在暂存区域生成了快照，等待被提交。通过“git rm –cached README.txt”命令，可以将文件状态还原为未暂存状态，即回到“Untracked files”文件状态。 图示 1234567graph LR工作区-Workspace--&gt;暂存区-IndexStage暂存区-IndexStage--&gt;本地仓库-Repository本地仓库-Repository--&gt;远程仓库-Remote本地仓库-Repository--&gt;工作区-Workspace远程仓库-Remote--&gt;本地仓库-Repository远程仓库-Remote--&gt;工作区-Workspace 步骤 操作 工作区-Workspace–&gt;暂存区-IndexStage add 暂存区-IndexStage–&gt;本地仓库-Repository commit 本地仓库-Repository–&gt;远程仓库-Remote push 本地仓库-Repository–&gt;工作区-Workspace checkout 远程仓库-Remote–&gt;本地仓库-Repository clone 远程仓库-Remote–&gt;工作区-Workspace pull(fetch/merge) 注意 只有暂存区域的文件（即：文件状态为“Changes to be committed”）才会被提交，提交到本地仓库。 如果不想通过暂存区而直接提交，可以使用git commit -a命令，这个命令可以将所以已经跟踪过的文件暂存起来一并提交，而不用git add。（未跟踪的不行）提交时注意添加说明git commit -a -m “Add a description” git add既可以用来跟踪新的文件（新增、删除），亦可以将已经跟踪的文件添加到暂存区（修改）。暂存区是下一次提交的文件，因此git add也可以理解为将此文件作为下次提交的文件。 重要概念 远程跟踪分支：“远程的”标记名称（如 :origin）+ “/“ + 远程仓库里分支的真正名称（“远程名称”是一个代码仓库别名，和本地目录或URL是一个含义，你可以通过”==git remote==”命令自由定义额外的“远程名称”。但“git clone”命令==默认==使用的是“origin”这个名称。） 123456git branch -rorigin/Dev_Br_20190528origin/HEAD -&gt; origin/masterorigin/Hot_Br_20190513origin/Hot_Br_20190514origin/master 命令使用 命令 功能 git fetch 从远端的源仓库更新到本地的代码仓库，执行完命令还不会立即将下载的文件合并到你当前工作目录里，你需要执行一个“合并（merge）”操作：git merge origin/master git rebase https://www.cnblogs.com/kidsitcn/p/5339382.html 【==待整理TODO==】","categories":[{"name":"Git","slug":"Git","permalink":"https://moon-zhou.github.io/categories/Git/"}],"tags":[]},{"title":"序列化","slug":"序列化","date":"2019-06-16T09:46:34.000Z","updated":"2019-09-08T07:52:46.327Z","comments":true,"path":"2019/06/16/序列化/","link":"","permalink":"https://moon-zhou.github.io/2019/06/16/序列化/","excerpt":"问题引入 个人会员wap系统，新增实名申诉降级流程，开发过程中，涉及选择已实名账号，上传证件等多步骤操作，后端一开始就要缓存实名用户的信息，缓存的地方为session。因为我们需要进行会话保持，从而我们使用了公司的snf-web-session组件，其底层实现是将缓存在session里的数据缓存在redis中，而不是web容器里。但是在我们实际的场景里，缓存塞值的时候是没有问题，但是在取值的时候，始终是null。","text":"问题引入 个人会员wap系统，新增实名申诉降级流程，开发过程中，涉及选择已实名账号，上传证件等多步骤操作，后端一开始就要缓存实名用户的信息，缓存的地方为session。因为我们需要进行会话保持，从而我们使用了公司的snf-web-session组件，其底层实现是将缓存在session里的数据缓存在redis中，而不是web容器里。但是在我们实际的场景里，缓存塞值的时候是没有问题，但是在取值的时候，始终是null。 猜测原因 HttpRequest只能在controller层使用，不能在更下层使用。[修改后发现问题没有解决] 是否是塞值的时候有异常，断点调试时无法复现，加入try-catch后未发现异常。 发现缓存的抽象类没有实现序列化接口，猜测需要进行序列化。修改后功能正常。 什么是序列化 官方解释：将对象的状态信息转换为可以存储或传输的形式的过程 简言之：了保存在内存中的各种实例对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来（也可以理解为不同jvm之间共享实例对象的一种解决方案） 为什么序列化 当你想把的内存中的对象状态保存到一个文件中或者数据库中时候 当你想用套接字在网络上传送对象的时候 当你想通过RMI/rpc调用传输对象的时候 如何进行序列化 Java里的序列化 Serializable是Java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化跟反序列化操作 继承关系的序列化 父类实现Serializable时，子类被序列化，父类也会被序列化。 父类没有实现Serializable时，子类被序列化，父类不会被序列化 引用关系的序列化 如果对一个实现了Serializable的类进行序列化操作，则同时对它的引用类进行序列化操作。如果引用类没有实现Serializable接口，JVM会抛出java.io.NotSerializableExeception:此时对Person类进行序列化操作，则会同时对Tool类进行序列化操作。若Tool类没有实现Serializable接口，则会抛出异常。 12345678class Person implements Serializable&#123; private String name; private Tool tool = new Tool();&#125;class Tool implements Serializable&#123; &#125; 特殊字段（敏感数据等）不需要进行序列化：使用transient进行修饰 序列化标识ID：serialVersionUID 当你序列化的时候这个UID会被写入文件,当反序列话的时候会去读取这个ID,并与反序列化的类中的UID对比,如果相同,那么反序列化就成功,如果不同,反序列化就会失败。如果设置了UID，即使字段发生==结构变化==，也会反序列化成功。所以手动指定UID,主要就是在类结构发生变化时,减少反序列化失败的几率(如果类发生了==非常规的结构变化==,比如类名变化,成员变量的类型变化,就算是指定了UID,反序列化也会失败) 当你不指定UID的时候,系统会根据类的结构生成相应的hash值赋值给UID,但是当你的类的结构发生变化,比如增加一个字段或者减少一个字段的时候,UID就会发生变化,那么反序列话的时候两个类的UID就不一样了,就会反序列化失败 序列化与反序列化 写入文件和读取文件：ObjectOutputStream-writeObject，ObjectInputStream-readObject 自定义序列化策略 定制序列化策略：Java提供了一套有效的机制，允许在序列化和反序列化时，使用定制的方法进行相应的处理。当传输双方协定好序列化策略后，只需要在需要传输的序列化类中添加一组方法来实现这组策略，在序列化时会自动调用这些规定好的方法进行序列化和反序列化。（策略的实现及底层含义：分别是将特定的对象写入到输出流中以及从输入流中恢复特定的对象，通过这==两个方法==，用户即可实现自定义的序列化。当在实现Serializable接口的类中写了上面两个方法之后，序列化或反序列化该类时则会通过反射来调用这两个方法，从而实现自定义序列化。）示例如下： 123456789private void writeObject(ObjectOutputStream out) throws IOException &#123; out.defaultWriteObject(); out.writeInt(age);// customize &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); age = in.readInt(); // customize &#125; Externalizable 该关键字序列化过程会调用类的无参构造函数-public，去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中 序列化的细节需要由开发者去完成，实现writeExternal()与readExternal()方法 限制序列化对象的数量：通过反序列化获取实例，则单例模式会失效。解决方案：可以让我们在序列化和反序列化时，可以根据自己的需要，写入或读取指定的实例。使用这种机制，需要在实现Serializable接口的类中添加两个方法： private Object readResolve() //如果用户在序列化类中添加了该方法，则在进行反序列化时，使用该方法返回的对象，作为反序列化对象。 private Object writeReplace() //如果用户在序列化类中添加了该方法，则在进行序列化时，序列化该类返回的对象。 12345678910111213141516171819202122232425public class Singleton implements Serializable &#123; private volatile static Singleton mInstance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (mInstance == null) &#123; synchronized (Singleton.class) &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; &#125; &#125; return mInstance; &#125; private Object readResolve() &#123; return getInstance(); &#125; private Object writeReplace() &#123; return getInstance(); &#125;&#125; 注意点 通过intent传递过去的对象是经过了序列化与反序列化的,虽然传送的对象和接收的对象内容相同,但是是不同的对象,他们的引用是不同的 静态变量及方法是不会经过序列化的,所以跨进程通信的时候静态变量是传送不过去的 静态变量。因为静态变量属于类的属性，并不属于某个具体实例，因此在序列化的时候无须进行序列化，反序列化时，可以直接获取类的静态成员引用。 方法。方法只是一系列的操作集合，方法不会依赖对象，不会因为对象的不同，而操作不同，反序列化时，也可以从类中直接获取方法信息。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://moon-zhou.github.io/categories/JAVA/"}],"tags":[]},{"title":"傻瓜式学Vue-02一步一步小demo","slug":"傻瓜式学Vue-02一步一步小demo","date":"2019-06-02T14:25:34.000Z","updated":"2019-09-08T07:52:48.422Z","comments":true,"path":"2019/06/02/傻瓜式学Vue-02一步一步小demo/","link":"","permalink":"https://moon-zhou.github.io/2019/06/02/傻瓜式学Vue-02一步一步小demo/","excerpt":"学前准备 了解基本的html/js/css语法 了解前端组件的基本概念","text":"学前准备 了解基本的html/js/css语法 了解前端组件的基本概念 热身demo 动手试一下：参考上一步初始化的项目，在App.vue里尝试编写自己的内容，编写完成，在当前目录cnpm run dev测试即可。 12345678910111213141516171819202122232425&lt;!-- 第一部分 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 第二部分 --&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: &apos;First Vue Code Test.&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- 第三部分 --&gt;&lt;style&gt;body &#123; font-family: Arial, Helvetica, sans-serif;&#125;&lt;/style&gt; 此处注意点：无解释说明，记住即可 一个vue一个template标签 一个template下只有一个div标签，不能并行多个div标签 注意data方法的返回写法 玩玩组件 在/src/component下仿照APP.vue的格式创建一个vue 12345678910111213141516171819&lt;template&gt; &lt;div id=&quot;handsomeBoy&quot;&gt; &lt;h1&gt;handsome head&lt;/h1&gt; &lt;a&gt;a handsome boy &#123;&#123;author&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; author: &apos;houxiaoxiao&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 然后在App.vue 使用组件 ( 因为在 index.html里面定义了div，id=”app”所以就以这个组件作为主入口，方便 ) 引入。 在标签内的第一行写：import handsomeboy from ‘./components/HandSomeBoy.vue’ 注册。 在标签内的 data代码块后面加上components:{handsomeboy}。 使用。 在内加上 完整代码如下： HandSomeBoy.vue 12345678910111213141516171819&lt;template&gt; &lt;div id=&quot;handsomeBoy&quot;&gt; &lt;h1&gt;handsome boy component&lt;/h1&gt; &lt;a&gt;a handsome boy &#123;&#123;author&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; author: &apos;houxiaoxiao&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; APP.vue 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 第一部分 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;!-- 组件第三步 --&gt; &lt;hr&gt; &lt;h2&gt;handsome boy 组件&lt;/h2&gt; &lt;handsomeboy&gt;&lt;/handsomeboy&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 第二部分 --&gt;&lt;script&gt;// 组件第一步import handsomeboy from &apos;./components/HandSomeBoy.vue&apos;export default &#123; data () &#123; return &#123; msg: &apos;First Vue Code Test.&apos; &#125; &#125;, // 组件第二步 components:&#123;handsomeboy&#125;&#125;&lt;/script&gt;&lt;!-- 第三部分 --&gt;&lt;style&gt;body &#123; font-family: Arial, Helvetica, sans-serif;&#125;&lt;/style&gt; 使用路由搭建单页应用 安装vue-router cnpm install vue-router –save 按之前的步骤，再写一个BeautifulGirl组件，代码如下： BeautifulGirl.vue 12345678910111213141516171819&lt;template&gt; &lt;div id=&quot;beautifulGirl&quot;&gt; &lt;h1&gt;beautiful girl component&lt;/h1&gt; &lt;a&gt;a beautiful girl &#123;&#123;author&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; author: &apos;XXX&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; HelloWorld.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;https://vuejs.org&quot; target=&quot;_blank&quot; &gt; Core Docs &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://forum.vuejs.org&quot; target=&quot;_blank&quot; &gt; Forum &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://chat.vuejs.org&quot; target=&quot;_blank&quot; &gt; Community Chat &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://twitter.com/vuejs&quot; target=&quot;_blank&quot; &gt; Twitter &lt;/a&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=&quot;http://vuejs-templates.github.io/webpack/&quot; target=&quot;_blank&quot; &gt; Docs for This Template &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Ecosystem&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;http://router.vuejs.org/&quot; target=&quot;_blank&quot; &gt; vue-router &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;http://vuex.vuejs.org/&quot; target=&quot;_blank&quot; &gt; vuex &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;http://vue-loader.vuejs.org/&quot; target=&quot;_blank&quot; &gt; vue-loader &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://github.com/vuejs/awesome-vue&quot; target=&quot;_blank&quot; &gt; awesome-vue &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;HelloWorld&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; index.js 1234567891011121314151617181920import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;import BeautifulGirl from &apos;@/components/BeautifulGirl&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/helloworld&apos;, name: &apos;HelloWorld&apos;, component: HelloWorld &#125;, &#123; path: &apos;/beautifulgirl&apos;, name: &apos;BeautifulGirl&apos;, component: BeautifulGirl &#125; ]&#125;) App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- 第一部分 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;1. &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;!-- 组件第三步 --&gt; &lt;hr&gt; &lt;h2&gt;2. handsome boy 组件&lt;/h2&gt; &lt;handsomeboy&gt;&lt;/handsomeboy&gt; &lt;!-- 路由 --&gt; &lt;hr&gt; &lt;h2&gt;3. 路由&lt;/h2&gt; &lt;div class=&quot;nav-box&quot;&gt; &lt;p class=&quot;nav-list&quot;&gt; &lt;router-link class=&quot;nav-item&quot; to=&quot;/helloworld&quot;&gt;helloworld&lt;/router-link&gt; &lt;router-link class=&quot;nav-item&quot; to=&quot;/beautifulgirl&quot;&gt;beautifulgirl&lt;/router-link&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 第二部分 --&gt;&lt;script&gt;// 组件第一步import handsomeboy from &apos;./components/HandSomeBoy.vue&apos;export default &#123; data () &#123; return &#123; msg: &apos;First Vue Code Test.&apos; &#125; &#125;, // 组件第二步 components: &#123; handsomeboy &#125;&#125;&lt;/script&gt;&lt;!-- 第三部分 --&gt;&lt;style&gt;body &#123; font-family: Arial, Helvetica, sans-serif;&#125;&lt;/style&gt; 示例地址https://github.com/moon-zhou/VueDemo 严重参考 https://www.runoob.com/w3cnote/vue2-start-coding.html 待学习https://www.cnblogs.com/chase-star/p/10455703.html","categories":[{"name":"Vue","slug":"Vue","permalink":"https://moon-zhou.github.io/categories/Vue/"}],"tags":[]},{"title":"傻瓜式学Vue-01搭建环境、初始化项目","slug":"傻瓜式学Vue-01搭建环境、初始化项目","date":"2019-06-02T14:23:34.000Z","updated":"2019-09-08T07:52:50.742Z","comments":true,"path":"2019/06/02/傻瓜式学Vue-01搭建环境、初始化项目/","link":"","permalink":"https://moon-zhou.github.io/2019/06/02/傻瓜式学Vue-01搭建环境、初始化项目/","excerpt":"学前准备 了解node 了解win下环境变量的概念，命令行的基本操作","text":"学前准备 了解node 了解win下环境变量的概念，命令行的基本操作 环境搭建 安装node，下载地址https://nodejs.org/en/ 傻瓜式安装，注意安装目录，尽量不要在c盘。注意版本最好选10，需要升级的下载覆盖原有安装即可。 确认安装完成 node -v 配置npm的全局模块的存放路径以及cache的路径，防止安装在c盘，使用npm config ls查看配置是否生效。 配置文件D:\\DevProgram\\nodejs\\node_modules\\npm\\npmrc，添加配置如下：prefix=D:\\DevProgram\\nodejs\\node_globalcache=D:\\DevProgram\\nodejs\\node_cache或者使用命令npm config set cache “D:\\vueProject\\nodejs\\node_cache”npm config set prefix “D:\\vueProject\\nodejs\\node_global” 安装淘宝npm镜像 由于npm是国外的，使用起来比较慢，我们这里使用淘宝的cnpm镜像来安装vue.淘宝的cnpm命令管理工具可以代替默认的npm管理工具。 安装命令：npm install -g cnpm –registry=https://registry.npm.taobao.org 配置环境变量，将上面prefix的目录配置到path，完成即可使用cnpm替代npm命令 安装webpack cnpm install webpack -g 安装vue cnpm install vue -g 安装全局vue-cli脚手架 cnpm install –global vue-cli或者cnpm install vue -g验证：输入vue，出来vue的信息，及说明安装成功 新项目的创建 vue init webpack my-project-first 进入my-project-first文件夹 cnpm install cnpm run dev 访问http://localhost:8080/#/ 打包：cnpm run build 安装IDE VSCode &amp; WebStorm 导入创建的文件夹 目录结构介绍：或有些微不同 1234567891011121314151617181920212223242526272829303132333435363738394041├── README.md 项目介绍├── index.html 入口页面├── build 构建脚本目录│ ├── build-server.js 运行本地构建服务器，可以访问构建后的页面│ ├── build.js 生产环境构建脚本│ ├── dev-client.js 开发服务器热重载脚本，主要用来实现开发阶段的页面自动刷新│ ├── dev-server.js 运行本地开发服务器│ ├── utils.js 构建相关工具方法│ ├── webpack.base.conf.js wabpack基础配置│ ├── webpack.dev.conf.js wabpack开发环境配置│ └── webpack.prod.conf.js wabpack生产环境配置├── config 项目配置│ ├── dev.env.js 开发环境变量│ ├── index.js 项目配置文件│ ├── prod.env.js 生产环境变量│ └── test.env.js 测试环境变量├── mock mock数据目录│ └── hello.js├── package.json npm包配置文件，里面定义了项目的npm脚本，依赖包等信息├── src 源码目录 │ ├── main.js 入口js文件│ ├── app.vue 根组件│ ├── components 公共组件目录│ │ └── title.vue│ ├── assets 资源目录，这里的资源会被wabpack构建│ │ └── images│ │ └── logo.png│ ├── routes 前端路由│ │ └── index.js│ ├── store 应用级数据（state）│ │ └── index.js│ └── views 页面目录│ ├── hello.vue│ └── notfound.vue├── static 纯静态资源，不会被wabpack构建。└── test 测试文件目录（unit&amp;e2e） └── unit 单元测试 ├── index.js 入口脚本 ├── karma.conf.js karma配置文件 └── specs 单测case目录 └── Hello.spec.js 严重参考 https://www.jianshu.com/p/0c6678671635 https://www.cnblogs.com/zhaomeizi/p/8483597.html","categories":[{"name":"Vue","slug":"Vue","permalink":"https://moon-zhou.github.io/categories/Vue/"}],"tags":[]},{"title":"web安全交流","slug":"web安全交流","date":"2019-05-18T14:59:34.000Z","updated":"2019-09-08T07:51:56.829Z","comments":true,"path":"2019/05/18/web安全交流/","link":"","permalink":"https://moon-zhou.github.io/2019/05/18/web安全交流/","excerpt":"web安全交流 web常用攻击手段 waf的简介 实际的攻击/漏洞案例 其他","text":"web安全交流 web常用攻击手段 waf的简介 实际的攻击/漏洞案例 其他 web常用攻击手段web端目前被报的常见安全攻击 sql注入 XSS CSRF SSRF 无限制的url sql注入防御方法定义预编译的sql语句XSS(Cross Site Scripting)XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。跨站脚本的重点不在‘跨站’上，而在于‘脚本’上。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码。实际上是在目标网站的作用域下执行了这段js代码。 示例留言板(商品评价等)XSS：用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。 危害通过document.cookie盗取cookie 使用js或css破坏页面正常的结构与样式 流量劫持（通过访问某段具有window.location.href定位到其他页面） 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。防御方法输入过滤、校验 输入验证（客户端）：前端JS过滤，如检测最大长度、是否只有合法字符、格式是否符合要求、数字是否在指定的范围内。缺点就是容易被修改掉。 数据消毒（服务器端filter拦截统一处理，如图一）：过滤敏感字符（可以和SQL注入的一同过滤），如&lt; &gt; javascript等。 输出编码 HttpOnly：攻击者通过XSS漏洞执行JS中的document.cookie方法来窃取用户的cookie信息。Web应用程序在Set-Cookie时将其属性设为HttpOnly即可避免Cookie被客户端JS存取，也可以保护用户的Cookie信息不被盗取 尽量使用WAF图一 @Component(&quot;specialCharacterFilter&quot;) public class SpecialCharacterFilter extends HttpServlet implements Filter { private static final Logger LOGGER = LoggerFactory.getLogger(SpecialCharacterFilter.class); /** * serialVersionUID */ private static final long serialVersionUID = 3092325909076672931L; /** * */ protected FilterConfig config; /** * {@inheritDoc} */ public void destroy() { } /** * {@inheritDoc} */ public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) { try { if (BankSwitchSCMConfig.get(&quot;XSSSWITCH&quot;).equals(&quot;1&quot;)) { HttpServletRequest request = (HttpServletRequest) req; @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; }) HashMap&lt;String, String[]&gt; m = new HashMap(request.getParameterMap()); HashMap&lt;String, String[]&gt; mm = new HashMap&lt;String, String[]&gt;(); if (m.size() &gt; 0 &amp;&amp; processParameters(m, mm)) { ParameterRequestWrapper wrapRequest = new ParameterRequestWrapper(request, mm); chain.doFilter(wrapRequest, res); } else { chain.doFilter(req, res); } } else { chain.doFilter(req, res); } } catch (Exception e) { LOGGER.info(&quot;过滤器异常:{}&quot;, e); } } /** * {@inheritDoc} */ public void init(FilterConfig arg0) throws ServletException { this.config = arg0; } /** * 功能描述: &lt;br&gt; * 〈功能详细描述〉 * * @param m * @param mm * @return */ public boolean processParameters(HashMap&lt;String, String[]&gt; m, HashMap&lt;String, String[]&gt; mm) { Iterator&lt;Map.Entry&lt;String, String[]&gt;&gt; iterator = m.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry&lt;String, String[]&gt; entry = iterator.next(); String key = entry.getKey(); String[] values = entry.getValue(); int len = values.length; for (int i = 0; i &lt; len; i++) { if (null != values[i]) { values[i] = values[i].trim(); // 分号|小于号|大于号|单引号 values[i] = values[i].replaceAll(&quot;;&quot;, &quot;&amp;#46;&quot;); values[i] = values[i].replaceAll(&quot;&lt;&quot;, &quot;&amp;#60;&quot;); values[i] = values[i].replaceAll(&quot;&gt;&quot;, &quot;&amp;#62;&quot;); values[i] = values[i].replaceAll(&quot;&apos;&quot;, &quot;&amp;#39;&quot;); values[i] = values[i].replaceAll(&quot;\\\\(&quot;, &quot;&amp;#40;&quot;); values[i] = values[i].replaceAll(&quot;\\\\)&quot;, &quot;&amp;#41;&quot;); } } mm.put(key, values); } return true; } }CSRF（跨站伪造请求 Cross—Site Request Forgery）原理 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B（这个过程可使用XSS配合，将用户引导到B网站-钓鱼网站） 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息（通过XSS获取用户cookie信息），向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行检测方法抓包后去除referer重放请求，能正常请求则有可能csrf重放示例本质原因CSRF攻击是源于Web的隐式身份验证机制！Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。CSRF攻击的一般是由服务端解决。防御方法该攻击能够成功有两个要点： 构造请求的参数都是可控的 网站没有验证请求的来源 因此防御csrf也可以从这两个方面入手 请求中增加token，token的不可控可以使得请求失败（可以提取公共组件） 限制请求来源referer（不妥，可伪造，目前门户只是做了这个校验） Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。 SSRF(服务器端请求伪造 Server-Side Request Forgery)利用漏洞伪造服务器端发起请求，从而突破客户端获取不到数据限制。是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。利用一个可以发起网络请求的服务，当作跳板来攻击其他服务，最常见的例子是通过web接口请求受保护网络内的资源。通常SSRF被用来扫描内网网络、攻击内网或者本地应用程序、读取本地文件等。 原理SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能但没有对目标地址做过滤与限制。当目标地址为服务端内网地址时，就会获取到内网的消息，从而进行服务器请求伪造攻击。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载、翻译、识图等功能。例如wooyun-2016-0198176。有道翻译对输入链接没有限制，可以直通内网。正常的流程是用户输入一个链接，然后针对这个链接进行翻译，但是如果输入的是该网站内网的一个链接，并且没有针对输入进行过滤的话，就会将内网的信息给展示出来。 常见漏洞常见 分享：通过URL地址分享网页内容 转码服务 在线翻译 图片加载与下载：通过URL地址加载或下载图片 图片、文章收藏功能 未公开的api实现以及其他调用URL的功能 从URL关键字中寻找 WAF介绍 云谛Web应用防火墙（Web Application Firewall, 简称 WAF）主要用于保障业务的正常运转。WAF可以防御注入(args，headers，cookie)、跨站脚本（XSS）、木马上传等OWASP常见攻击，并过滤海量恶意CC攻击。是应用软件的第一道防火墙，保护了网站资产的安全，网络服务的可用性。在接入WAF后，即启用Web应用防火墙。启用之后，您网站所有的流量都会先经过Web应用防火墙，恶意攻击流量在Web应用防火墙上被检测过滤，而正常流量返回给源站IP，从而确保源站IP安全、稳定、可用。参考链接 waf的功能 拦截非法请求。 业务需要，暂时下线某个功能时，代码逻辑无法控制的时候，配置waf黑名单，拒绝请求。 某个请求存在代码bug，功能不可用时，需要下线该功能。 waf的主要配置 限制单ip使用频率，不同环境次数的配置有不同的转换系数，具体环境配置时咨询waf平台。 黑名单配置（功能2/3可使用该配置） 根据攻击特点配置拦截，比如相同的UA 根据攻击参数进行拦截，比如pcToken，这个我们无法配置，需要waf平台帮忙配置。 以上都需要waf平台帮忙进行分析请求的共性，来指导我们进行相关过滤规则的配置。 实际案例攻击案例 未登录情况下，找回支付密码时，发送验证码之前，使用的是数字验证码（固定验证方式），被机器识别，大量调用发送短信验证码端口。wiki记录 pptv拉新安全问题。wiki记录 passport短信登录获取验证码攻击问题。wiki记录 登录合规改造（防重放） 任意url跳转 安全应急中心提的安全问题单 反射型XSS 其他漏洞靶场vulhub 提升网站安全圈 安全开发 门户敏感功能未监控到位，尤其是未登录状态下的功能。 敏感功能可接入风控 正确使用GET,POST和Cookie（csrf）。GET常用在查看，列举，展示等不需要改变资源属性的时候；POST常用在下达订单，改变一个资源的属性或者做其他一些事情。","categories":[{"name":"内部分享","slug":"内部分享","permalink":"https://moon-zhou.github.io/categories/内部分享/"}],"tags":[]},{"title":"代码规范第二期","slug":"代码规范第二期分享","date":"2019-05-18T14:58:34.000Z","updated":"2019-09-08T07:51:51.789Z","comments":true,"path":"2019/05/18/代码规范第二期分享/","link":"","permalink":"https://moon-zhou.github.io/2019/05/18/代码规范第二期分享/","excerpt":"代码规范第二期code style 编程到底是什么样的一种活动 将需求明确到机器可以执行的细节程度,就是编程要做的事,而这种规范或者说约束,正是代码。 态度:你是专业的程序员,不要做不专业的事。经理维护进度和需求,警察维护治安,清洁工维护卫生状况,你则要维护代码。 你能分辨代码好坏,并不代表你能写出好代码。 代码大部分时候是用来维护的，而不是用来实现功能的。 在代码阅读过程中人们说脏话的频率是衡量代码质量的唯一标准。 clean code","text":"代码规范第二期code style 编程到底是什么样的一种活动 将需求明确到机器可以执行的细节程度,就是编程要做的事,而这种规范或者说约束,正是代码。 态度:你是专业的程序员,不要做不专业的事。经理维护进度和需求,警察维护治安,清洁工维护卫生状况,你则要维护代码。 你能分辨代码好坏,并不代表你能写出好代码。 代码大部分时候是用来维护的，而不是用来实现功能的。 在代码阅读过程中人们说脏话的频率是衡量代码质量的唯一标准。 clean code 小原则 定义你自己的代码阅读等级范围 明确下经常读你代码的人他们的水平在什么程度，这样我们就可以明确我们的Clean 究竟要Clean到什么程度。 多读同事的代码或者开源代码（以人为镜）。 编码规则及案例 面向接口编程，使用接口声明 不推荐方式： ArrayList list = new ArrayList(); 推荐方式： List list = new ArrayList(); DB、IO操作等需要使用结束close()的对象必须在try-catch-finally 的finally中close()，如果有多个对象需要close()，需要分别对每个对象的close()方法进行try-catch，防止一个对象关闭失败其他对象都未关闭` try {//业务处理 } catch (Exception e) {//异常处理 } finally {//资源关闭处理 }` 注释会骗人（当注释和代码实际的实现出现偏差时，代码才是唯一） 大量字符串的相加等处理应该使用StringBuilder 或StringBuffer，并且预设容量值。 大量：一般指5次“+=”以上或者在循环中进行字符串+=操作。 容量值：构造器会创建一个默认大小(通常是16)的字符数组。在使用中，如果超出这个大小，就会重新分配内存，每次自然递增(OldNum * 2) +2 个，创建一个更大的数组，并将原先的数组复制过来，再丢弃旧的数组。 注意：多线程并发使用StringBuffer，局部变量单线程使用StringBuilder。 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);` public static String filterHTMLTagInStyle(String htmlStr) {String reg_html=&quot;regex&quot;; Pattern pattern= Pattern.compile(reg_html,Pattern.CASE_INSENSITIVE); Matcher matcher=pattern.matcher(htmlStr); htmlStr=matcher.replaceAll(&quot;&quot;); //过滤html标签 return htmlStr; }` 接口类中的方法和属性不要加任何修饰符号（public 也不要加，默认），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 用户敏感数据禁止直接展示，必须对展示数据脱敏（隐位规则统一处理）。同时门户系统，对隐私信息的传输，也需要进行加密（现阶段是非对称加密）。传输的方式使用post方式，禁止get方式（安全扫描会报安全漏洞）。 用户请求传入的任何参数必须做有效性验证。 使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。 命名 如果使用到了设计模式，建议在类名中体现出具体模式,有利于阅读者快速理解架构设计思想。 正例：public class OrderFactory; 枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。 说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 生产问题(刚刚出炉的热乎bug)不发布的情况下，产生的bug系列 上线但运行4个月无反馈的bughttp://wiki.cnXXX.com/pages/viewpage.action?pageId=33621924 跟随系统一起交接过来的bughttp://wiki.cnXXX.com/pages/viewpage.action?pageId=33622386 系统njs升级涉及代码bughttp://wiki.cnXXX.com/pages/viewpage.action?pageId=33621010 解决方案 code review从目前小组全员review来看，效果不是很好。可以考虑迁移git之后，从代码提交时就进行code review。 终极解决方案：人（唯心） ==》 Later Is Never表象行为：“稍后再….”，稍后再抽个方法，稍后再重命名，稍后再重构，稍后再验证这个场景等等。这个时候就要各位小心，往往稍后再XXX是没有稍后的。 你还得练,孩子,还得练(共勉)","categories":[{"name":"内部分享","slug":"内部分享","permalink":"https://moon-zhou.github.io/categories/内部分享/"}],"tags":[]},{"title":"代码规范第二期 backup","slug":"代码规范第二期 backup","date":"2019-05-18T14:58:34.000Z","updated":"2019-09-08T07:51:54.230Z","comments":true,"path":"2019/05/18/代码规范第二期 backup/","link":"","permalink":"https://moon-zhou.github.io/2019/05/18/代码规范第二期 backup/","excerpt":"代码规范第二期code style 规范 形而上，但是的确很重要也很实用的原则 定义你自己的代码阅读等级范围 方法视角：先实现基本方法，之后再在方法内抽取进行重构 接口/类视角：有多个待实现的方法，最后一个方法实现之后，再进行重构 大的视角来看，我们需要遵循原则，但是代码很多时候是运行在具体的场景里。因此写合适的代码， 细节上的注意点 注释会骗人（代码才是唯一）","text":"代码规范第二期code style 规范 形而上，但是的确很重要也很实用的原则 定义你自己的代码阅读等级范围 方法视角：先实现基本方法，之后再在方法内抽取进行重构 接口/类视角：有多个待实现的方法，最后一个方法实现之后，再进行重构 大的视角来看，我们需要遵循原则，但是代码很多时候是运行在具体的场景里。因此写合适的代码， 细节上的注意点 注释会骗人（代码才是唯一） 生产问题(刚刚出炉的热乎bug)不发布的情况下，产生的bug系列 上线但运行4个月无反馈的bughttp://wiki.cnXXX.com/pages/viewpage.action?pageId=33621924 跟随系统一起交接过来的bughttp://wiki.cnXXX.com/pages/viewpage.action?pageId=33622386 系统njs升级涉及代码bughttp://wiki.cnXXX.com/pages/viewpage.action?pageId=33621010 自我升级终极解决方案（唯心）：人 ==》 Later Is Never表象行为：“稍后再….”，稍后再抽个方法，稍后再重命名，稍后再重构，稍后再验证这个场景等等。这个时候就要各位小心，往往稍后再XXX是没有稍后的。 你还得练,孩子,还得练(共勉)","categories":[{"name":"内部分享","slug":"内部分享","permalink":"https://moon-zhou.github.io/categories/内部分享/"}],"tags":[]},{"title":"使用hexo搭建个人博客--结合github","slug":"使用hexo搭建个人博客--结合github","date":"2019-05-18T13:49:34.000Z","updated":"2019-09-08T14:20:59.710Z","comments":true,"path":"2019/05/18/使用hexo搭建个人博客--结合github/","link":"","permalink":"https://moon-zhou.github.io/2019/05/18/使用hexo搭建个人博客--结合github/","excerpt":"环境搭建 安装node，参考傻瓜式学vue里的步骤即可。【注意使用淘宝镜像，npm安装速度可能存在比较慢的情况】","text":"环境搭建 安装node，参考傻瓜式学vue里的步骤即可。【注意使用淘宝镜像，npm安装速度可能存在比较慢的情况】 怎么与github一起操作：参考本人整理文档github新增代码库实操.md 安装hexo cnpm install -g hexo cnpm install -g hexo-cli 开始blog 初始化blog：hexo init 将md文档放到source_posts目录下 配置文档_config.yml，对它做如下修改，repository后面的内容是 git@gitbub.com:username/库地址 的形式， 生成静态文档（public目录为最终blog内容）：hexo g(根目录下时用该命令) 开启本地服务：hexo s，打开浏览器访问 http://localhost:4000 即可看到内容。 hexo d，把public下生成的最终文件发布到github上 【TODO】修改主题： 【TODO】图床问题：https://www.jianshu.com/p/950f8f13a36c 错误解决 DeprecationWarning: fs.SyncWriteStream is deprecated 原因：hexo版本过低 解决：npm install hexo-fs –save 严重参考 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://www.cnblogs.com/zhongxia/p/9980353.html","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://moon-zhou.github.io/categories/HEXO/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-06-27T14:44:34.000Z","updated":"2019-09-08T07:52:11.021Z","comments":true,"path":"2017/06/27/hello-world/","link":"","permalink":"https://moon-zhou.github.io/2017/06/27/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Test","slug":"Test","permalink":"https://moon-zhou.github.io/categories/Test/"}],"tags":[]}]}